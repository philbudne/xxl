
# XXL build/test Makefile

# set XXL_PYTHON on command line (eg; "make XXL_PYTHON=pypy3")
#	to override xxl.py "#!" line choice of Python interpreter

PARSER= parser

PARSER_SRC=$(PARSER).xxl

# precompiled VM code for parser
PARSER_VMX=$(PARSER).vmx

# .xxl files in lib/
# distribution .vmx files in dist/
LIB=	lib:dist

# note: using $(PARSER_VMX).[abc] looks like a (suffix) rule?!
A=	a.vmx
B=	b.vmx
C=	c.vmx

# VM sources:
XXL=	xxl.py
VM=	$(XXL) vmx.py classes.py const.py jslex.py xxlobj.py scopes.py

# XXX XXX XXX run ./test.sh test suite?? when (using $(B))??

# NOTE: when changing generated code, "a" and "b" will differ
#	otherwise they should be identical.

TESTED=tested
ABIDENTICAL=.identical.ab

# XXX lib/*.xxl and lib/ext/*.xxl too!
DOCS= classes.html

all:	$(TESTED) $(DOCS)

$(TESTED): $(C) $(ABIDENTICAL)
	cmp $(B) $(C)
	XXL_PARSER=$(C) CMD="$(XXL_PYTHON) ./$(XXL)" ./test.sh
	@if cmp $(B) $(PARSER_VMX);  then \
	    echo no change to $(PARSER_VMX); \
	else \
	    test -f $(PARSER_VMX) && mv -f $(PARSER_VMX) $(PARSER_VMX).bak;\
	    cp -fp $(B) $(PARSER_VMX); \
	    echo updated $(PARSER_VMX); \
	fi
	date > $(TESTED)

$(ABIDENTICAL): $(A) $(B)
	@if cmp -s $(A) $(B); then \
		echo "no change in generated code"; \
		date > $(ABIDENTICAL); \
	else \
		echo "NOTE: generated code changed"; \
	fi

################

classes.html: classes.py .bootstrap lib/doc.xxl lib/markup.xxl $(TESTED)
	./$(XXL) lib/doc.xxl classes > classes.html

# uncomment to enable timing
#TIME=time -p

# not working?
# XXL_LIB_PATH=$(LIB)

RUNVMX=$(TIME) $(XXL_PYTHON) ./$(XXL)

$(PARSER_VMX):
	test -f $(PARSER_VMX) || cp -f dist/$(PARSER_VMX) .

# step A: run PARSER_VMX on PARSER_SRC generating $(A) VMX file
# Compiles, but DOES NOT RUN new source.
# Not dying here only means parser.xxl is syntactically correct.
# A separate step just so the (old) generated code is visible;
# MOST of the time (no generated code changes) "a" will match "b" and "c"
$(A):	$(VM) $(PARSER_SRC) $(PARSER_VMX)
	$(RUNVMX) $(PARSER_VMX) $(PARSER_SRC) > $(A).tmp && mv $(A).tmp $(A)

# step B: use output of step A to self-generate VM code
#	(running code generated by parser.vmx)
# this runs the modified parser.xxl file on itself.
$(B):	$(VM) $(A) $(PARSER_SRC)
	$(RUNVMX) $(A) $(PARSER_SRC) > $(B).tmp && mv $(B).tmp $(B)

# step C: test self-generated VM code from step B
#	should always return identical results to step B
$(C):	$(VM) $(B) $(PARSER_SRC)
	$(RUNVMX) $(B) $(PARSER_SRC) > $(C).tmp && mv $(C).tmp $(C)

# XXX test new file (w/ recursive make????) before replacing?!!
.bootstrap bootstrap.vmx: bootstrap.xxl $(PARSER_VMX) $(VM)
	$(RUNVMX) $(PARSER_VMX) bootstrap.xxl > bootstrap.vmx.tmp
	@if [ -f bootstrap.vmx ] && cmp bootstrap.vmx bootstrap.vmx.tmp; then \
	    echo no change to bootstrap.vmx; rm -f bootstrap.vmx.tmp; \
	else \
	    test -f bootstrap.vmx && mv -f bootstrap.vmx  bootstrap.vmx.bak; \
	    mv bootstrap.vmx.tmp bootstrap.vmx; \
	    echo updated bootstrap.vmx; \
	fi
	@touch .bootstrap

################
# run ONLY before git checkin for main repo
# (so clean checkouts get initial VM code)

install-dist: $(TESTED) $(DOCS) .bootstrap
	cp $(PARSER_VMX) bootstrap.vmx $(DOCS) dist/

# manually check if dist dir up to date (before git checkin)
# skip first line in each VMX file (skip metadata)
check-dist: $(PARSER_VMX)
	@for FILE in $(PARSER_VMX) bootstrap.vmx; do \
	    tail -n+2 $$FILE > .tmp.c; \
	    tail -n+2 dist/$$FILE > .tmp.d; \
	    if cmp -s .tmp.c .tmp.d; then \
		echo "dist/$$FILE up to date"; \
	    else \
		echo "NOTE: dist/$$FILE out of date"; \
	    fi; \
	done
	@grep -v 'formatted by doc.xxl' classes.html > .tmp.c
	@grep -v 'formatted by doc.xxl' dist/classes.html > .tmp.d
	@if cmp -s .tmp.c .tmp.d; then \
	    echo "dist/classes.html up to date"; \
	else \
	    echo "NOTE: dist/classes.html out of date"; \
	fi
	@rm -f .tmp.[cd]

################
GENERATED=$(A) $(B) $(C) $(TESTED) $(ABIDENTICAL) $(DOC)
clean:
	rm -f *.tmp .tmp* *.bak *~ $(GENERATED)
	rm -rf __pycache__
