# XXL build/test Makefile

# set XXL_PYTHON on command line (ie; "make XXL_PYTHON=pypy3")
#	to override xxl.py "#!" line choice of Python interpreter

PARSER= parser

PARSER_SRC=$(PARSER).xxl

# VM code for parser preloaded into System.parser
PARSER_VMX=$(PARSER).vmx

# note: using $(PARSER_VMX).[abc] looks like a (suffix) rule?!
A=	a.vmx
B=	b.vmx
C=	c.vmx

# VM sources:
XXL=	xxl.py
VM=	$(XXL) vmx.py classes.py const.py jslex.py system.py scopes.py

# XXX XXX XXX run ./test.sh test suite?? when (using $(B))??

# NOTE: when changing generated code, "a" and "b" will differ
#	otherwise they should be identical.

TESTED=tested
IDENTICAL=.identical.ab
IDENTICAL2=.identical.parser-c

all:	$(TESTED) $(IDENTICAL) $(IDENTICAL2)

$(TESTED): $(B) $(C)
	cmp $(B) $(C)
	XXL_PARSER=$(C) CMD="$(XXL_PYTHON) ./$(XXL)" ./test.sh
	date > $(TESTED)

$(IDENTICAL): $(A) $(B)
	@if cmp -s $(A) $(B); then \
		echo "no change in generated code"; \
		date > $(IDENTICAL); \
	else \
		echo "NOTE: generated code changed"; \
	fi

# XXX skip first line in each file (skip metadata)?
$(IDENTICAL2): $(PARSER_VMX) $(C)
	@tail -n+2 $(C) > .tmp.c
	@tail -n+2 $(PARSER_VMX) > .tmp.p
	@if cmp -s .tmp.c .tmp.p; then \
		echo "$(PARSER_VMX) up to date"; \
	else \
		echo "NOTE: $(PARSER_VMX) out of date (update from $(C))"; \
	fi
	@rm -f .tmp.c .tmp.p

install: $(TESTED)
	cp $(C) $(PARSER_VMX)	

#TIME=time -p
RUNVMX=$(TIME) $(XXL_PYTHON) ./$(XXL) -x

# step A: run PARSER_VMX on PARSER_SRC generating VMX
# Compiles, but DOES NOT RUN new source.
# Not dying here only means parser.xxl is syntactically correct.
# A separate step just so the (old) generated code is visible;
# MOST of the time (no generated code changes) "a" will match "b" and "c"
$(A):	$(VM) $(PARSER_VMX) $(PARSER_SRC)
	$(RUNVMX) $(PARSER_VMX) $(PARSER_SRC) > $(A).tmp && mv $(A).tmp $(A)

# step B: use output of step A to self-generate VM code
#	(running code generated by parser.vmx)
# this runs the modified parser.xxl file on itself.
$(B):	$(VM) $(A) $(PARSER_SRC)
	$(RUNVMX) $(A) $(PARSER_SRC) > $(B).tmp && mv $(B).tmp $(B)

# step C: test self-generated VM code from step B
#	should always return identical results to step B
$(C):	$(VM) $(B) $(PARSER_SRC)
	$(RUNVMX) $(B) $(PARSER_SRC) > $(C).tmp && mv $(C).tmp $(C)

# XXX save old (working) file??
bootstrap.vmx: bootstrap.xxl $(PARSER_VMX) $(VM)
	$(RUNVMX) $(PARSER_VMX) bootstrap.xxl > bootstrap.vmx.tmp && \
		mv bootstrap.vmx.tmp bootstrap.vmx

clean:
	rm -f *.tmp $(A) $(B) $(C) $(TESTED) $(IDENTICAL) $(IDENTICAL2) .tmp*
	rm -rf __pycache__
