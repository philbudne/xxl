// -*-js-*-

const __doc = "Classes for marking up machine generated documentation.";

var MarkUp = Class.new({
    name: "MarkUp",
    doc: "base class for marking up text",
    methods: {
	_init: function (this) { this._value = []; },
	init: function (this) { this._init(); }, // XXX TEMP!
	render: function (this) {
	    """
	    return final result Str
	    """
	    return("".join(this._value));
	},
	joinw: function(this, list) {
	    """
	    join words and return Str
	    """
	    return(" ".join(list));
	},
	append: function (this, ...words) {
	    """
	    append words (w/o any newlines)
	    """
	    var s = this.joinw(words);
	    if (s.len() > 0) {
		this._value.append(s);
	    }
	},
	nappend: function (this, ...words) {
	    """
	    start new line, then append words (w/ spaces)
	    """
	    if (this._value.len() > 0 &&
		this._value[-1].len() > 0 &&
		this._value[-1][-1] != "\n") {
		this._value.append("\n"); // start new line
	    }
	    if (words.len()) {
		this._value.append(this.joinw(words));
	    }
	},
	lwrap: function (this, prefix, list, suffix) {
	    """
	    wrap `list` of items between `prefix` and `suffix`
	    AND RETURN String
	    """
	    suffix = suffix || ""; // want "||=" or "??=" ??
	    var l = this.joinw(list);
	    return("".join([prefix, l, suffix]));
	},
	wrapnap: function (this, prefix, words, suffix) {
	    """
	    concatenate List of Str `words`
	    wrap in prefix/suffix
	    start new line and append
	    """
	    this.nappend(this.lwrap(prefix, words, suffix));
	},
	quote: function (this, text) {
	    return(text);
	}
    } // methods
});

var HTML = Class.new({
    name: "HTML",
    doc: "MarkUp class for HTML",
    supers: [MarkUp],
    methods: {
	init: function (this) {
	    var html = __xxl.pyimport("html");
	    // quick crock!
	    // Should replace `thing` with <code>thing</code> AFTER!!
	    this.quote = html.escape; // override default method!!
	    this._init();	      // XXX TEMP
	},
	_twrap: function (this, tag, list) {
	    var open = "<" + tag + ">";
	    var close = "</" + tag + ">";
	    return(this.lwrap(open, list, close));
	},
	_hn: function (this, n, list) {
	    this.nappend(this._twrap( "h" + n.to_str(), list));
	},

	make_anchor: function (this, name) {
	    """
	    Create internal document link destination
	    """
	    // prepend something unlikely to name if github markdown auto-anchors confuse things?!
	    this.nappend('<a name="' + name + '"></a>');
	},

	// the following take multiple args, will space separate and APPEND.
	h1: function (this, ...args) { this._hn(1, args); },
	h2: function (this, ...args) { this._hn(2, args); },
	h3: function (this, ...args) { this._hn(3, args); },
	h4: function (this, ...args) { this._hn(4, args); },
	h5: function (this, ...args) { this._hn(5, args); },
	hn: function (this, n, ...args) { this._hn(n, args); },

	hr: function (this, ...args) { this.nappend("<hr>\n"); },
	p: function (this, ...args) { this.nappend("<p>\n"); }, // paragraph
	blockquote: function (this, ...args) {
	    this.nappend(this._twrap("blockquote", args));
	},

	start_color: function (this, color) {
	    //this.append('<span style="color:' + color + '">');
	    this.append('<font color="' + color + '">');
	},
	end_color: function (this) {
	    //this.append('</span>');
	    this.append('</font>');
	},

	// code_block?
	// (un)ordered_list (take list)??

	// NOTE!! the following RETURN strings:
	bold: function (this, ...words) {
	    return(this._twrap("b", words));
	},
	i: function (this, ...words) {
	    return(this._twrap("i", words));
	},
	code: function (this, ...words) {
	    return(this._twrap("code", words));
	},
	link: function (this, dest, ...words) {
	    """
	    display `words` as a link to `dest`
	    """
	    return(this.lwrap('<a href="' + dest + '">', words, '</a>'));
	},
	ilink: function (this, name, ...words) {
	    """
	    display `words` as an internal document link to anchor `dest`
	    """
	    // prepend something unlikely to name if github markdown auto-anchors confuse things?!
	    return(this.link('#' + name, ...words));
	}
    }
});

var MarkDown = Class.new({
    name: "MarkDown",
    doc: "MarkUp class for MarkDown (.md) format!",
    supers: [HTML],
    methods: {
	// the following take multiple args, will space separate and APPEND.
	h1: function (this, ...args) { this.wrapnap("# ", args, "\n"); },
	h2: function (this, ...args) { this.wrapnap("## ", args, "\n"); },
	h3: function (this, ...args) { this.wrapnap("### ", args, "\n"); },
	h4: function (this, ...args) { this.wrapnap("#### ", args, "\n"); },
	h5: function (this, ...args) { this.wrapnap("##### ", args, "\n"); },
	hn: function (this, n, ...args) {
	    this.wrapnap("##########".slice(0,n) + " ", args, "\n");
	},

	hr: function (this, ...args) { this.nappend("---\n\n"); }, // github was combining
	p: function (this, ...args) { this.nappend("\n"); }, // paragraph
	blockquote: function (this, ...args) {
	    this.wrapnap("> ", args, "\n\n");
	},

	// code_block?
	// (un)ordered_list (take list)??

	// NOTE!! the following RETURN strings:
	bold: function (this, ...words) {
	    return(this.lwrap("**", words, "**"));
	},
	i: function (this, ...words) {
	    return(this.lwrap("*", words, "*"));
	},
	code: function (this, ...words) {
	    return(this.lwrap("`", words, "`"));
	},
	link: function (this, dest, ...words) {
	    return(this.lwrap("[", words, "]") + "(" + dest + ")");
	}
	// use HTML ilink!
    }
});
