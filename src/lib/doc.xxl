// -*-js-*-

const __doc = "Program to extract and markup documentation from an XXL Module";

const classes = __xxl.import("classes");

const re = __xxl.pyimport("re");

const ADDR_RE = re.compile(" at 0x[0-9a-z]*");

const SUPER_COLOR = "slategray";

// XXX need general iterator for class and all supers

var collect_class_ops = function (class, prop) {
    """
    traverse Class hierarchy for `class`
    collecting all methods/operators from property `prop`
	(one of '__methods', '__unops', '__binops', '__lhsops')
	returns Dict of Callables
    """
    var funcs = {};
    var props = {};
    var q = [class];
    var visited = {};
    var visit = function (c) {
	if (c !== classes.Object) { // XXX UGH! Stop The Looping!!!
	    q.extend(c.__supers || []);
	}

	// member (static) functions come first in MRO
	// (see classes.py find_in_supers)
	if (prop == '__methods') {
	    c.props().for_each(
		function (mprop) { // member property name
		    if (mprop.starts_with("_")) { // ignore private members
			return();
		    }
		    var value = c.getprop(mprop);
		    if (value.instance_of(classes.Callable)) {
			if (!funcs[mprop]) {
			    funcs[mprop] = value;
			}
		    }
		    else if (!props[mprop]) {
			props[mprop] = value;
		    }
		}
	    ); // c.props().for_each
	} // __methods
	c.getprop(prop).items().for_each(
	    function (item) {	// item is [key, value]
		var name = item[0];
		var func = item[1];
		if (!name.starts_with("_")     // ignore private methods
		    && func && !funcs[name]) { // don't overwrite!
		    funcs[name] = func;
		}
	    }
	); // getprop(prop).items().for_each
    }; // visit
    while (q.len() > 0) {
	visit(q.pop(0));
    }
    return([funcs, props]);
};

var mudoc = function(mu, obj) {
    """
    mark up obj.__doc
    """
    var doc = obj.__doc;
    mu.p();
    if (!doc) {
	return();
    }
    // split into lines,
    // strip leading/trailing whitespace from lines,
    // ignoring empty lines, rejoin
    // apply quoting (eg for HTML entities)
    // XXX honor blank lines as paragraph breaks!!!!
    // XXX don't smoosh ```stuff```!!
    var strip = function (x) { return(mu.quote(x.strip())); };
    mu.blockquote(" ".join(doc.split("\n").map2(strip, "")));
};

var mufunc = function (mu, level, name, func, not_own_method) {
    """
    Markup a function/method.
    `level` is header level, `name` is opr/function name, `func` is Callable.
    """
    var args = func.__args() || "(?)"; // get string for argument names
    if (not_own_method) {
	mu.start_color(SUPER_COLOR);
    }
    // apply (HTML entity) quoting for operators
    mu.hn(level, mu.code(mu.quote(name), args));
    var defn = func.__defn() || "?"; // get class and definition location
    mu.nappend(mu.i(func.getclass().name, "at", defn));
    mudoc(mu, func);
    if (not_own_method) {
	mu.end_color();
    }
};

var muvalue = function (mu, level, name, value) {
    """
    mark up a variable with a non-callable value
    """
    mu.hn(level, mu.code(name));
    mu.nappend(mu.i(value.getclass().name));
    var vstr = ADDR_RE.sub("", value.repr()); // remove " at 0xXXXX"
    mu.blockquote(mu.code(mu.quote(vstr)));
};

var muclass = function (mu, class) {
    """
    `mu` is a MarkUp instance,
    `class` is a Class (metaclass) to document
    """

    mudoc(mu, class);

    [
     ['__methods', 'Methods'],
     ['__unops', 'Unary operators'],
     ['__binops', 'Binary operators'],
     ['__lhsops', 'LHS Binary operators']
    ].for_each(			// for_each property
	 function (pitem) {	// pitem => ["property", "english"]
	     var mprop = pitem[0]; // property for methods
	     var mtype = pitem[1]; // english name for method type
	     var stuff = collect_class_ops(class, mprop);
	     var m = stuff[0];	// dictionary of methods
	     if (m.len() > 0) {
		 mu.h3(mtype);	// english name
		 mu.p();

		 m.items().sorted().for_each(
		     function (ditem) { // ditem => [method/op_name, function]
			 var name = ditem[0]; // method name or operator string
			 var func = ditem[1]; // Callable
			 var own_method = class.hasprop(mprop) && class.getprop(mprop)[name];
			 mufunc(mu, 4, name, func, !own_method);
		     }
		 );
	     } // have methods
	     m = stuff[1];	// dict of members (only w/ regular methods)
	     if (m.len() > 0) {
		 mu.h3("Members");
		 mu.p();
		 m.items().sorted().for_each(
		     function (ditem) { // ditem => [member_name, value]
			 var name = ditem[0]; // method name or operator string
			 var value = ditem[1];
			 var own_member = class.hasprop(name);
			 if (!own_member) {
			     mu.start_color(SUPER_COLOR);
			 }
			 muvalue(mu, 4, name, value);
			 if (!own_member) {
			     mu.end_color();
			 }
		     } // function (ditem)
		 ); // for_each member
	     }
	 } // function (pitem)
    ); // for_each property
};

var mumodule = function (mu, module_name) {
    """
    Import and up a module.
    `module_name` is name to import.
    """
    var mod = __xxl.import(module_name);

    mu.head(module_name + " | " + (mod.__doc ? mod.__doc.to_str() : "Mystery Module"));
    mu.h1("Module", mu.code(module_name));
    mu.p();
    mudoc(mu, mod);
    // not yet working:
    // mu.p();
    // mu.start_color(SUPER_COLOR);
    // mu.append("(inherited methods in this color)");
    // mu.end_color();

    // iterate over sorted names in Module
    var vars = [];
    mod..props().sorted().for_each(
	function (name) {
	    if (name.starts_with("_")) {
		return();
	    }
	    var x = mod.getprop(name);
	    if (x.instance_of(classes.Class)) {
		mu.hr();
		mu.make_anchor("class-" + name);

		var link_class_if_known = function (c) {
		    """
		    Take Class object, return link to (hopeful) definition
		    (if defined in this file), else return plain name.
		    """
		    var cname = c.name;
		    // must be defined at top level;
		    if (mod.hasprop(cname) && mod.getprop(cname) === c) {
			return(mu.ilink("class-" + cname, cname));
		    }
		    else {
			return(cname);
		    }
		};

		var metaclass = x.getclass();
		mu.h2(mu.code(link_class_if_known(metaclass)), // metaclass name (typ. Class)
		      mu.code(name), "subclass of",	       // class name
		      mu.code(",".join(x.__supers.map(link_class_if_known)))
		); // h2

		mu.p();
		muclass(mu, x);
	    }
	    else {
		vars.append(name);
	    }
	}
    );
    if (vars.len() == 0) {
	return();
    }
    mu.hr();
    mu.h2("Variables");
    mu.p();
    vars.for_each(
	function (name) {
	    var x = mod.getprop(name);
	    if (x.instance_of(classes.Callable)) {
		mufunc(mu, 3, name, x);
	    }
	    else {
		muvalue(mu, 3, name, x);
	    }
	    mu.p();
	}
    );
};

if (__modinfo.main) {
    var markup = __xxl.import("markup.xxl");
    var markup_class = markup.MarkDown;
    var i = 0;
    if (__xxl.argv.len() > i && __xxl.argv[i] == "--html") {
	markup_class = markup.HTML;
	i += 1;
    }
    var module_name = __xxl.argv.len() > i ? __xxl.argv[i] : "classes";

    var mu = markup_class.new();

    mumodule(mu, module_name);

    mu.hr();
    var time = __xxl.pyimport("time");
    mu.nappend("formatted by doc.xxl on",
	       time.strftime("%Y-%m-%d")); // XXX want UTC

    // The very very very end.
    __xxl.print(mu.render());	// output results
}
