// not -*-js-*- ("it's only a model") but edit like it is.
// Parser for eXperimental/eXtensible Language Zero (XXL/0)
// Blame: Phil Budne <phil _at_ regressive.org>

////////////////
// Adapted from:
//  parse.js
//  Parser for Simplified JavaScript written in Simplified JavaScript
//  From Top Down Operator Precedence
//  http://crockford.com/javascript/tdop/tdop.html
//  https://github.com/douglascrockford/TDOP
//  Douglas Crockford
//  2021-05-04
//  Public Domain
//
//  "This program makes frequent use of 'this' because I wrote it when I was young and foolish."
////////////////

// Changes Copyright Â© 2021,2023 Philip L. Budne

// PLB: NOTE!

// I've compounded the 'thissyness' by making the parser into a
// class, not SO much because one might want to have multiple
// active parsers in the same namespace, but to (try) to make it
// easier to override parser pieces (thru subclassing) without
// wholesale copying.  Further work is needed to make that a
// reality (isolating the creation of each Symbol class into
// a separate method??).

// In XXL "this" is always passed as explicit first argument (like
// Python) to make it clear where the value is coming from.  At least
// *I* think it's a feature.

// The individual Symbol classes could probably be declared at top
// level *IF* the nud/led/std parsing methods were passed the Parser
// instance as an argument.  This might be a great improvement in
// clarity, but would mean more arg passing, *AND* it would carve the
// Symbol subclass inheritance graph in stone...  Perhaps time (and
// attempts to use this toolkit to create new languages) will point the
// way....

// Converted to a narrow(minded) Class/instance data model; the
// hobgoblins of my small mind can't cope with the duality of
// "instances" being used as prototypes -- while it might detour the
// class/metaclass mobius/gordian straightjacket, it also obscures the
// origin of objects, and their structure/nature, and easily leads to
// chimerical objects of unclear origin, with parts glued on all over.

// I've refrained from placing any licensing terms on this file,
// in keeping with the spirit of the original author placement of
// the code into the public domain.

// It's more than slightly likely that you would be better served by
// using the original (TDOP) parser as the starting point for some new
// project!!

// XXX split up?? All imported modules would need to be pre-compiled (vmx files)

const __doc = "Extensible Parser/Compiler for XXL.";

const classes = __xxl.import("classes"); // SingletonClass

// XXX move to vmcode.xxl?
var VMCode = Class.new({
    name: "VMCode",
    methods: {
	init: function (this) {	// __init??
	    this.code = [];
	    this.lcount = 0;	// counts down for forward labels
	    this.forward_refs = {}; // dict of lists of insn Lists for fixups
	    this.DEST = 2;	// index into insn List for branch destination
	},

	finish: function (this, sym) {
	    if (sym === null) {
		// here from end of "gen" function, used by parser.xxl "main"
		this.emit_exit(); // emits EOF "return"
	    }
	    else {
		// no more return statement, it has ceased to be.
		// BUT, here at end of closures (even functions which
		// call their "return" continuation) *AND* blocks.
		this.emit_return(sym);
	    }
	    return(this.code);
	},
	gen_push: function (this, symbol) {
	    // evaluate "this" and push on stack (*may* crush AC)
	    if (symbol.arity == "literal") {
		this.emit_push_lit(symbol.value, symbol);
	    }
	    else {
		symbol.gen(this);
		this.emit_push(symbol);
	    }
	},
	gen_stmts: function (this, stmts) { // generate code for list of stmts
	    stmts.for_each(
		function (item) {
		    // call this.gen_stmt to emit optional "stmt" Instr
		    // for breakpoint/trace/profiling??
		    item.gen(this);
		}
	    );
	},
	_emit: function (this, op) { // worker method
	    var p = this.peep;	     // one instruction peephole
	    if (p) {
		// omit "load x" after "store x"	(use after defn)
		if (p[1] == "store" && op[1] == "load" && op[2] == p[2]) {
		    //__xxl.error("dropping", op, "after", p);
		    return();
		}
		// omit "store x" after "store x"	(x = x = y)
		// omit "store x" after "load x"	(x = x)
		// omit "load x" after "load x" (if store after load eliminated)
		// replace "load x" if followed by "load y" (unlikely)
		// drop anything after jrst or return (requires const prop)
	    }
	    this.code.append(op);
	    this.peep = op;
	},

	//// per-opcode emit functions

	emit_var: function (this, name, sym) {
	    this._emit([sym.where, "var", name]);
	},
	emit_args: function (this, names, sym) {
	    this._emit([sym.where, "args", names]);
	},
	emit_args2: function (this, names, rest, sym) {
	    this._emit([sym.where, "args2", names, rest]);
	},
	emit_scope: function (this, leave_sym, sym) {
	    if (leave_sym) {
		this._emit([sym.where, "lscope", leave_sym.value]);
	    }
	    else {
		this._emit([sym.where, "uscope"]);
	    }
	},
	emit_load: function (this, name, sym) {
	    this._emit([sym.where, "load", name]);
	},
	emit_store: function (this, name, sym) {
	    this._emit([sym.where, "store", name]);
	},
	emit_lit: function (this, value, sym) {
	    this._emit([sym.where, "lit", value]);
	},
	emit_push_lit: function (this, value, sym) {
	    this._emit([sym.where, "push_lit", value]);
	},
	emit_push: function (this, sym) {
	    this._emit([sym.where, "push"]);
	},
	emit_new: function (this, class, sym) {
	    // push TEMP onto stack, create empty container, leave in TEMP
	    this._emit([sym.where, "new", class]);
	},
	emit_temp: function (this, sym) {
	    // load AC from TEMP
	    this._emit([sym.where, "temp"]);
	},
	emit_pop_temp: function (this, sym) {
	    // load AC from TEMP, restore TEMP from stack
	    this._emit([sym.where, "pop_temp"]);
	},
	emit_return: function (this, sym) {
	    // return from call, value in AC
	    this._emit([sym.where, "return"]);
	},
	emit_exit: function (this) {
	    // VM exit; return to "boot0" which contains exit instr
	    this._emit(["EOF", "return"]);
	},
	emit_binop: function (this, op, sym) {
	    // fetch and call binary operator "op" (constant)
	    // for object in AC with two args: OBJ, RHS
	    this._emit([sym.where, "binop", op]);
	},
	emit_unop: function (this, op, sym) {
	    // fetch and call unary operator "op" (const)
	    // for object in AC (no args)
	    this._emit([sym.where, "unop", op]);
	},
	emit_lhsop: function (this, op, sym) {
	    // fetch and call LHS operator "op" (const)
	    // for object in AC w/ three args from stack: OBJ, RHS, VALUE
	    this._emit([sym.where, "lhsop", op]);
	},
	emit_binop_lit: function (this, op, value, sym) {
	    this._emit([sym.where, "binop_lit", op, value]);
	},
	emit_call: function (this, nargs, sym) {
	    // call object in AC with nargs (constant) args on stack
	    // call collects args in vm.args and calls AC.invoke(vm)
	    this._emit([sym.where, "call", nargs]);
	},
	emit_close: function (this, code, sym) {
	    // create closure
	    // include function name (if any) in Closure object?!!
	    this._emit([sym.where, "close", code, sym.doc]);
	},
	emit_bclose_call: function (this, vmcode, sym) {
	    // create {} block closure and call
	    this._emit([sym.where, "bccall", vmcode.finish(sym)]);
	},
	emit_append: function (this, sym) {
	    // for [] List literal values
	    this._emit([sym.where, "append"]);
	},

	// for calls w/ ...arg
	emit_clargs: function (this, sym) {
	    this._emit([sym.where, "clargs"]);
	},
	emit_poparg: function (this, sym) {
	    this._emit([sym.where, "poparg"]);
	},
	emit_sprarg: function (this, sym) {
	    this._emit([sym.where, "sprarg"]);
	},
	emit_call0: function (this, sym) {
	    this._emit([sym.where, "call0"]);
	},

	// on PDP-10:
	// JUMPN ac,x jumps if ac is non-zero
	// JUMPE ac,x jumps if ac is equal to zero
	// JUMP never jumps
	// JUMPA always jumps, but...
	// JRST (jump and restore (no) flags) is fastest unconditional branch.
	emit_iftrue: function (this, label, sym) {
	    this._emit_branch("jumpn", label, sym);
	},
	emit_ifnot: function (this, label, sym) {
	    this._emit_branch("jumpe", label, sym);
	},
	emit_jrst: function (this, label, sym) {
	    this._emit_branch("jrst", label, sym);
	},

	//// label management:
	_emit_branch: function (this, instname, dest, sym) {
	    // helper to emit a branch instruction
	    // keeping fixups for forward refs

	    // NOTE!!! label must be in this.DEST position:
	    var inst = [sym.where, instname, dest];
	    if (dest < 0) {		// forward ref?
		this.forward_refs[dest].append(inst); // point to inst
	    }
	    this._emit(inst);
	},
	def_fwd_label: function (this) {
	    // create a forward label (negative values)
	    // references are fixed in "drop_fwd_label"
	    this.lcount -= 1;
	    this.forward_refs[this.lcount] = [];
	    return(this.lcount);
	},
	drop_fwd_label: function (this, label) {
	    // define location of a forward-defined label
	    // do fixups on all references
	    var dest = this.code.len();
	    // XXX check if label in this.forward_refs?!
	    this.forward_refs[label].for_each(
		function (inst) {
		    inst[this.DEST] = dest;	// patch destination
		}
	    );
	    this.forward_refs.pop(label); // discard entry
	    //__xxl.error("discarding peep", this.peep);
	    this.peep = null;
	},
	get_off: function (this) {
	    // return offset of next inst for backwards jump (loop) labels
	    //__xxl.error("discarding peep", this.peep);
	    this.peep = null;
	    return(this.code.len());
	}
    } // methods
});

////////////////////////////////////////////////////////////////
// move to pratt.xxl?

var PrattParser = Class.new({
    name: "PrattParser",
    methods: {
	add_symbol_class: function (this, str, symbol_class) {
	    """
	    Add an operator or statement Symbol class to parser.
	    """
	    // XXX assert symbol_class.instance_of(this.Symbol) ??
	    // XXX assert str.instance_of("".getclass()) ????
	    this.symbol_classes[str] = symbol_class;
	},

	start_parse: function (this, fname, prefix, suffix, fatal) {
	    // XXX take error handler/callback/continuation!
	    this.scope = this.Scope.new(null);

	    var ret = __xxl._tokenizer(fname, prefix, suffix);
	    this.get_token = ret[0]; // Object w/ type, value & where properties
	    this.reset_prompt = ret[1]; // void function
	    this.pointer = ret[2]; // func(line,pos); prints line w/ pointer
	    this.interactive = ret[3]; // bool
	    this.reset_tokenizer = ret[4]; // void function

	    this._fatal = fatal || function () { __xxl.exit(1); };

	    this._token = null;	// current Symbol object
	    this.need_advance = true; // pump needs priming
	},

	_msg: function (this, where, prefix, token, msg) {
	    __xxl.error(where, prefix, msg, token.repr()); // to stderr
	    var l = where.split(':');
	    if (l.len() >= 3) {
		// XXX check fname??
		this.pointer(l[1].to_int(), l[2].to_int());
	    }
	},
	_error: function (this, where, token, msg) {
	    """Internal helper to format fatal error message."""
	    this._msg(where, "ERROR", token, msg);
	    this._fatal();	// call error handler (default is exit(1))
	},
	_warning: function(this, where, token, msg) {
	    """Internal helper to format warning message."""
	    this._msg(where, "WARNING", token, msg);
	},
	_t_error: function(this, t, msg) {
	    """Token error (for _gtok); `t` is a token from tokenizer."""
	    this._error(t.where, t.value, msg);
	    // NOTREACHED
	},
	_gtok: function (this) {
	    """
	    Internal helper: fetch next token, and create Symbol object.
	    Parse routines should call ctoken, check, peek, advance.
	    """
	    var t = this.get_token(); // get lexer token
	    var v = t.value;
	    var a = t.type; // arity (name,number,string,operator,EOF,ERROR)
	    var c;	    // class
	    var d;	    // definition (for name)
	    // var id = v;
	    if (a == "name") {
		if ((d = this.scope.find_definition(v))) { // previously seen?
		    c = d.getclass(); // could be variable or reserved word
		}
		else if (!(c = this.symbol_classes[v])) { // keyword?
		    // not a keyword and not (yet) defined as a variable.
		    // property/method names (that aren't variable names)
		    // end up here.
		    c = this.Symbol; // undefined error on reference in expr!!
		}
	    }
	    else if (a == "operator") {
		c = this.symbol_classes[v];
		if (!c) {
		    this._t_error(t, "Unknown operator");
		}
	    }
	    else if (a == "string" || a == "number") {
		c = this.Lit;
		a = "literal";
		// id = this.LIT;
	    }
	    else if (a == "EOF") {
		c = this.End;	// a SingletonClass!
		v = this.END;	// for advance(this.END)
	    }
	    else if (a == "ERROR") {
		this._t_error(t, t.msg);
	    }
	    else {
		this._t_error(t, "Unknown token type " + a);
	    }
	    var s = c.new(t.where, v, a); // Symbol
	    s.defn = d;	   // save to avoid repeating lookup in define
	    return(s);
	}, // _gtok

	ctoken: function (this) {
	    """
	    Return current token (Symbol).

	    Check if deferred advance needed, and fetch new token if needed
	    (was originally "check_advance", vs "cash_advance?!").
	    Advance no longer reads next token;
	     just marks new token is needed via need_advance,
	     so interactive REPL doesn't hang at end of stmt.
	    """
	    if (this.need_advance) {
		this.advance();
	    }
	    return(this._token);
	}, // ctoken

	check: function (this, id) {
	    """
	    Return `true` if Str `id` matches current token
	    (handles deferred advance).
	    """
	    return(this.ctoken().check(id));
	}, // check

	advance: function (this, id) {
	    """
	    Checks that current token matches optional Str `id`.
	    If need_advance is false, just set flag and return
	     so that REPL doesn't hang on `advance(";")`
	    """
	    if (id && !this.check(id)) { // ctoken will call us w/ null id!
		this._token.error("Expected " + id.repr() + " saw");
	    }
	    if (!this.need_advance) {
		this.need_advance = true; // defer, defer!!
		return();
	    }
	    if (this._next_token) { // saved from peek?
		this._token = this._next_token;
		this._next_token = null; // consume it
	    }
	    else {
		this._token = this._gtok();
	    }
	    this.need_advance = false;
	},
	peek: function (this) {	// peek at token after this._token
	    // you can only peek one token ahead!
	    if (!this._next_token) {
		this._next_token = this._gtok();
	    }
	    return(this._next_token);
	},

	_defname: function(this, where, name, arity, read_only) {
	    """
	    helper to define `name` in current scope.
	    """
	    var class = read_only ? this.ReadOnly : this.Name;
	    this.scope._define(class.new(where, name, arity));
	},

	_defname_internal: function(this, where, name, read_only) {
	    """
	    define `name` (arrived at w/o a Symbol) in current scope.

	    NOTE!!! Does NOT check for multiple definitions or "shadowing"
	    so ****NOT for use with user symbols***!!!
	    """
	    this._defname(where, name, "name", read_only);
	},

	define: function (this, sym, read_only) {
	    """
	    `sym` is a Parser Symbol instance.
	    declare as a Name/ReadOnly in the current scope.
	    """

	    // had a call to scope.find_definition to get "prev" here.
	    // sym.defn _seems_ like the right thing!

	    // give fatal error for duplicate (in same scope) before warning!
	    this._defname(sym.where, sym.value, sym.arity, read_only);

	    if (sym.defn) {	// previous definition in an outer scope
		sym.warning("shadows previous definition at " + sym.defn.where);
	    }
	},

	predef: function (this, name, read_only) {
	    """predefine Str `name` as a Name or ReadOnly"""
	    this._defname_internal("predefined", name, read_only);
	},

	reserve: function (this, token) {
	    """mark `token` (defaults to `Parser.ctoken()`) as reserved"""
	    this.scope.reserve(token || this.ctoken());
	},

	expression: function (this, rbp) {
	    var t = this.ctoken();
	    this.advance();
	    var left = t.nud();
	    while (rbp < (t = this.ctoken()).lbp) {
		this.advance();
		left = t.led(left);
	    }
	    return(left);
	}, // expression

	check_end: function (this) {
	    """
	    Check for EOF token. Called from bootstrap reader loop.
	    """
	    return(this.ctoken().eof); // see also check_end_block
	},

	check_end_block: function (this) {
	    """
	    Check for end of block or EOF token. Called from statements loop.
	    """
	    var t = this.ctoken();
	    return(t.end_block || t.eof); // see also check_end
	},

	statement_error: function (this, handler) {
	    """
	    Parse statement w/ error handler for REPL.
	    calls handler, or returns null on parse error.
	    """
	    // If local cleanup desired, and no handler, could save "return"
	    // in a var and create a closure that calls it after cleanup??

	    // thought about saving old _fatal, and resetting afterwards
	    // (which could use the aforementioned closure
	    // to restore the old value on an error).
	    this._fatal = handler || return;
	    return(this.statement());
	},

	statement: function (this, labeled) {
	    """
	    Parse a single statement: called from bootstrap reader loop.
	    """
	    var n = this.ctoken();
	    if (n.arity == "name") { // possible label name?
		var next = this.peek(); // peek at next token
		if (next.check(":")) {
		    // will be defined inside of a new scope (closure)
		    if (n.reserved) {
			n.error(n.value.repr() + ' reserved');
		    }
		    if (labeled) { // nested labels?
			n.error("Statement already labeled");
		    }
		    var nn = this.Label.new(n.where, n.value, "name");
		    nn.std();	// call Label.std (which calls this function)
		    return(nn);
		} // peek == ":"
	    } // name
	    var std = n.std;
	    if (std) {
		this.advance();
		this.reserve(n);
		return(std());
	    }
	    return(this.expression_statement());
	}, // statement

	expression_statement: function (this) {
	    var v = this.expression(0);
	    if (!this.interactive && !v.exp_stmt) {
		v.error("Bad expression statement");
	    }
	    this.advance(";");
	    return(v);
	}, // expression_statement

	init: function (this_parser) {
	    var p = this_parser; // brevity, "this" clarity

	    p.VMCode = VMCode;	// for use by extensions

	    p.symbol_classes = {}; // string to Symbol subclass

	    // defined inside class initializer so it can be overridden
	    // by subclasses of Parser.
	    p.Scope = Class.new({
		name: "Scope",
		methods: {
		    init: function (this, parent) {
			// dictionary of Symbol instances
			this.def = {};
			this.parent = parent;
		    },
		    _define: function (this, n) { // n is Symbol instance
			var t = this.def[n.value];
			if (t) { // previously defined in this scope??
			    n.error((t.reserved
				     ? "Reserved at "
				     : "Previously defined at ")
				    + t.where);
			}
			this.def[n.value] = n;
			n.reserved = false;
		    },
		    find_definition: function (this, n) {
			// n is Str (from lexer)
			// returns definition, if any (Symbol instance)
			var e = this;
			while (e) {
			    var o = e.def[n];
			    if (o) {
				return(o);
			    }
			    e = e.parent;
			}
			return(null);
		    },
		    pop: function (this) {
			"""
			Discard top scope.
			Returns old scope (new current scope)
			"""
			return(this.parent);
		    },
		    reserve: function (this, sym) {
			"""
			Mark name used as a keyword as reserved
			cannot be used as variable in this (or any nested scope).
			"""
			if (sym.arity != "name" || sym.reserved) {
			    return();
			}
			// NOTE!! In original (JavaScript) parser,
			// scope was per-function, and original code
			// was "var t = this.def[sym.value];"
			// BUT, XXL scope is per-block
			// (and there isn't CURRENTLY a way to only search
			//  to start of current function scope see comment
			//  on Scope.new in Function.nud method)
			//
			// 2021-06-17 Trying to avoid calling find_definition
			//  again by having _gtok stash lookup used to create
			//  Symbol in sym.defn.
			var t = sym.defn;
			if (t) {
			    if (t.reserved) {
				return();
			    }
			    if (t.arity == "name") {
				// here with an operator keyword previously
				// used as an identifier??
				sym.error("Defined at " + t.where);
			    }
			} // t
			this.def[sym.value] = sym;
			sym.reserved = true;
		    } // reserve
		} // methods
	    }); // Scope

	    ////////////////
	    // Parser Symbol (token) classes

	    // defined inside class initializer so it can be overridden
	    // by subclasses of Parser, AND so that Symbol class methods
	    // have access to the parser object (as "p"), but this could
	    // be done by explicitly passing the parser object to the
	    // nud/led/std methods.

	    // Maybe have a method that defines Symbol class, and each subclass
	    // to make it easier to subclass a Symbol before it's used to
	    // as a base class??

	    // Each class defined as a Class member, since used as base Class
	    // for other Classes defined in this init method, and in extensions!!

	    // Symbol nodes created for (as yet) undeclared identifiers.
	    p.Symbol = Class.new({
		name: "Symbol",
		doc: "Base class for parser AST nodes.",
		methods: {
		    init: function (this, where, value, arity) {
			this.where = where; // fname:line:charnum
			this.value = value; // Str or Number
			this.arity = arity; // "operator", "name", "literal"
			// XXX set reserved??
		    },
		    check: function (this, value) {
			"""check if symbol matches `value`"""
			// .id field originally existed w/ same value as .value
			// EXCEPT was "(literal)" for literals
			// NOTE: Lit.check always returns false.
			return(this.value == value);
		    },
		    nud: function (this) {
			"""
			"null denotation"
			invoked by parser at the start of an expression.
			"""
			this.error(this.arity == "name" ?
				   "Undefined symbol" : "Unexpected token");
		    },
		    led: function (this, ignore) {
			"""
			"left denotation" -- invoked by expression when there is
			context to the left of this symbol, honoring
			`.lbp` (left binding power) property.
			"""
			this.error("Missing operator");
		    },
		    error: function (this, msg) {
			"""
			Output a fatal error displaying token location and value.
			"""
			p._error(this.where, this.value, msg);
			// NOTREACHED
		    },
		    warning: function (this, msg) {
			"""
			Output a warning displaying token location and value .
			"""
			p._warning(this.where, this.value, msg);
		    },
		    gen: function (this, vmcode) {
			// XXX call gen_XXX based on this.arity???
			this.error("No gen function"); // XXX show class name??
		    }
		}, // methods
		props: {
		    lbp: 0
		}
	    }); // Symbol

	    p.Name = Class.new({
		name: "Name",
		supers: [p.Symbol],
		methods: {
		    nud: function (this) {
			return(this);
		    },
		    gen: function (this, vmcode) {
			vmcode.emit_load(this.value, this);
		    },
		    gen_lhs: function (this, vmcode) {
			vmcode.emit_store(this.value, this);
		    }
		}, // methods
		props: {
		    lvalue: true
		}
	    });

	    p.ReadOnly = Class.new({ // not named Const -- keep that for Stmt
		name: "ReadOnly",
		supers: [p.Name],
		methods: {
		    gen_lhs: function (this, vmcode) {
			// paranoia
			this.error("Should not happen (ReadOnly on LHS)");
		    }
		},
		props: {
		    lvalue: false // override from Name (make illegal on LHS)
		}
	    });

	    p.Lit = Class.new({
		name: "Lit",
		supers: [p.Symbol],
		methods: {
		    check: function (this, value) {
			"""Lit never matches in 'check' or 'advance'."""
			return(false);
		    },
		    nud: function (this) {
			// reserve only works for arity == "name", and
			// should only be here with arity == "literal"!!!
			p.reserve(this);
			return(this);
		    },
		    gen: function (this, vmcode) {
			vmcode.emit_lit(this.value, this);
		    } // gen
		} // methods
	    });

	    // pseudo-symbol for EOF
	    p.End = classes.SingletonClass.new({
		name: "End",
		supers: [p.Symbol],
		methods: {
		    nud: function (this) { return(this); }
		},
		props: {
		    end_block: true,
		    eof: true
		}
	    });
//	    p.End.end_block = true; // Class property
//	    p.End.eof = true;	    // Class property

	    p.END = "(EOF)";	// .value for End Symbol

	    //////////////// operator Symbol base classes

	    // Left associative infix (also base for InfixR)
	    p.Infix = Class.new({
		name: "Infix",
		supers: [p.Symbol],
		methods: {
		    led: function (this, left) {
			this.first = left;
			var rbp = this.lbp - this.right_assoc;
			this.second = p.expression(rbp);
			this.arity = "binary";
			return(this);
		    },
		    gen_infix: function (this, vmcode) {
			if (this.second.arity == "literal") {
			    this.first.gen(vmcode);
			    vmcode.emit_binop_lit(this.value, this.second.value, this);
			}
			else { // second NOT a Lit
			    vmcode.gen_push(this.second); // just push?
			    this.first.gen(vmcode);
			    vmcode.emit_binop(this.value, this);
			}
		    },
		    gen: function (this, vmcode) {
			// XXX have top level call gen_XXX based on arity?
			this.gen_infix(vmcode);
		    }
		}, // methods
		props: {
		    right_assoc: 0 // false: used in math
		}
	    });

	    // Right associative infix
	    p.InfixR = Class.new({
		name: "InfixR",
		supers: [p.Infix],
		props: {
		    right_assoc: 1 // true: used in math
		}
	    });

	} // init method
    } // methods
}); // PrattParser

// keep in parser.xxl?
////////////////////////////////////////////////////////////////
// subclass PrattParser for XXL/0
// (smallest possible eXperimental/eXtensible Language)
// "jokes":
// * PL/1 was IBM's "One Language to Rule Them All" for System/360
//	(the one computer architecture anyone would ever need).
//	PL/1 was meant to replace both FORTRAN for scientific code
//	 and COBOL for business applications; it was a large
//	 language which had no reserved words, and all numeric
//	 variables were declared with their precision.
// * XXL is the U.S. clothing size two sizes larger than "large"
//	which I thought was a funny name for an intentionally tiny language.
//	(the original name for the project was ASAP (As Simple As Possible).
//	Apologies in advance for any perceived sizist slights.

var Parser = Class.new({
    name: "Parser",
    supers: [PrattParser],
    methods: {
	init: function (this_parser) {
	    // XXX split into two parts,
	    // first which creates p.Classname variables
	    // second which uses them,
	    // so that the Classes can be overridden??

	    var p = this_parser; // for brevity
	    p.as_class(Parser)..init();	// call superclass init

	    // precedence levels (keep as Parser.PXXX properties??)
	    // ***USE EVEN VALUES ONLY: prec-1 used for right associativity!!!
	    p.PASS = 10;		// assignment

	    p.PTERN = p.PASS + 10;	// ternary

	    p.PLOR = p.PTERN + 10;	// logical or (||)
	    p.PLAND = p.PLOR + 10;	// logical and (&&)

	    p.PCOMP = p.PLAND + 10;	// comparison

	    p.PBOR = p.PCOMP + 10;	// bitwise or (|)

	    p.PBAND = p.PBOR + 10;	// bitwise and (&)

	    p.PADD = p.PBAND + 10;
	    p.PSUB = p.PADD;

	    p.PMUL = p.PSUB + 10;
	    p.PDIV = p.PMUL;

	    p.PPFX = p.PDIV + 10;	// prefix (unary)

	    p.PDOT = p.PPFX + 10;	// exp.member
	    p.PIDX = p.PDOT;		// exp[index]
	    p.PFUN = p.PDOT;		// exp(args)

	    p.Balanced = Class.new({
		doc: "Class for terminal symbols that are the right side of matched pairs.",
		supers: [p.Symbol],
		name: "Balanced",
		methods: {
		    nud: function (this) {
			this.error("Unbalanced");
		    }
		}
	    });

	    p.add_terminal("Colon",  ":");
	    p.add_terminal("Comma",  ",");
	    p.add_terminal("Semi",   ";");
	    p.add_terminal("RParen", ")", p.Balanced);
	    p.add_terminal("RBrack", "]", p.Balanced);
	    p.add_terminal("RBrace", "}", p.Balanced).end_block = true;
	    p.add_terminal("Else",   "else");

	    p.Assign = Class.new({
		supers: [p.InfixR],
		name: "Assign",
		methods: {
		    led: function (this, left) {
			if (!left.lvalue) {
			    left.error("Not allowed on LHS of assignment");
			}
			this.first = left;
			this.second = p.expression(this.lbp-1);
			this.arity = "binary";
			return(this);
		    },
		    gen: function (this, vmcode) {
			this.second.gen(vmcode); // rhs
			this.first.gen_lhs(vmcode); // store
		    }
		}, // methods
		props: {
		    lbp: p.PASS,
		    exp_stmt: true
		}
	    });
	    p.add_symbol_class("=", p.Assign);

	    // base class for OP=
	    p.AssignOp = Class.new({
		name: "AssignOp",
		supers: [p.Assign],
		methods: {
		    // subclass must define "aop" (want member)
		    gen: function (this, vmcode) {
			vmcode.gen_push(this.second); // save rhs as argument

			// XXX eval children of RHS once???

			this.first.gen(vmcode);  // fetch lhs as variable
			vmcode.emit_binop(this.aop, this);
			this.first.gen_lhs(vmcode); // store in lhs
		    }
		}
	    });

	    p.add_assignop = function (name, id, aop) {
		var C = Class.new({
		    name: name,
		    supers: [p.AssignOp],
		    props: { aop: aop }
		});
		p.add_symbol_class(id, C);
	    };
	    p.add_assignop("AssignPlus",  "+=", "+");
	    p.add_assignop("AssignMinus", "-=", "-");

	    p.Ternary = Class.new({
		name: "Ternary",
		supers: [p.Symbol],
		methods: {
		    led: function (this, left) {
			this.first = left;
			this.second = p.expression(0);
			p.advance(":");
			this.third = p.expression(0);
			this.arity = "ternary";
			return(this);
		    },
		    gen: function (this, vmcode) {
			this.first.gen(vmcode); // condition
			var false_label = vmcode.def_fwd_label();
			vmcode.emit_ifnot(false_label, this);

			this.second.gen(vmcode); // true case
			var done_label = vmcode.def_fwd_label();
			vmcode.emit_jrst(done_label, this);

			vmcode.drop_fwd_label(false_label);
			this.third.gen(vmcode); // false case

			vmcode.drop_fwd_label(done_label);
		    }
		}, // methods
		props: {
		    lbp: p.PTERN
		}
	    });
	    p.add_symbol_class("?", p.Ternary);

	    p.AndIf = Class.new({
		name: "AndIf",
		supers: [p.InfixR],
		methods: {
		    gen: function (this, vmcode) {
			this.first.gen(vmcode);
			var done_label = vmcode.def_fwd_label();
			vmcode.emit_ifnot(done_label, this); // lhs false: quit
			this.second.gen(vmcode); // lhs true: eval rhs
			vmcode.drop_fwd_label(done_label);
		    }
		},
		props: {
		    lbp: p.PLAND
		}
	    });
	    p.add_symbol_class("&&", p.AndIf);

	    p.OrIf = Class.new({
		name: "OrIf",
		supers: [p.InfixR],
		methods: {
		    gen: function (this, vmcode) {
			this.first.gen(vmcode); // eval lhs
			var done_label = vmcode.def_fwd_label();
			vmcode.emit_iftrue(done_label, this); // lhs true: done
			this.second.gen(vmcode); // lhs false: eval rhs
			vmcode.drop_fwd_label(done_label);
		    }
		},
		props: {
		    lbp: p.PLOR
		}
	    });
	    p.add_symbol_class("||", p.OrIf);

	    // right associative
	    p.add_infix("Is",  "===", true, p.PCOMP);
	    p.add_infix("Isnt","!==", true, p.PCOMP);
	    p.add_infix("Eq",  "==",  true, p.PCOMP);
	    p.add_infix("NEq", "!=",  true, p.PCOMP);
	    p.add_infix("LT",  "<",   true, p.PCOMP);
	    p.add_infix("LEq", "<=",  true, p.PCOMP);
	    p.add_infix("GT",  ">",   true, p.PCOMP);
	    p.add_infix("GEq", ">=",  true, p.PCOMP);

	    p.add_infix("BOr", "|",   true, p.PBOR);

	    p.add_infix("BAnd", "&",  true, p.PBAND);

	    // left associative
	    p.add_infix("Plus", "+",  false, p.PADD);

	    p.Prefix = Class.new({
		name: "Prefix",
		supers: [p.Symbol],
		methods: {
		    nud: function (this) {
			p.reserve(this); // in case keyword
			this.first = p.expression(p.PPFX); // XXX member for rbp?
			this.arity = "unary";
			return(this);
		    },
		    gen_prefix: function (this, vmcode) {
			this.first.gen(vmcode);
			vmcode.emit_unop(this.value, this);
		    },
		    gen: function (this, vmcode) { // XXX call gen_xxx on arity?
			this.gen_prefix(vmcode);
		    }
		}
	    }); // Prefix

	    // minus is infix and prefix operator:
	    p.Minus = Class.new({
		name: "Minus",
		supers: [p.Infix, p.Prefix],
		methods: {
		    gen: function (this, vmcode) {
			if (this.arity == "unary") {
			    this.gen_prefix(vmcode);
			}
			else {
			    this.gen_infix(vmcode);
			}
		    } // gen
		}, // methods
		props: {
		    lbp: p.PSUB
		}
	    });
	    p.add_symbol_class("-", p.Minus);

	    // right associative
	    p.add_infix("Mult", "*",  true, p.PMUL);
	    p.add_infix("Div", "/",   true, p.PDIV);

	    p.Dot = Class.new({
		name: "Dot",
		supers: [p.Symbol],
		methods: {
		    led: function (this, left) {
			// XXX bring back exp.NAME( ternary as optimization
			//	(avoid creating BoundMethod)????
			this.lvalue = true;
			this.first = left;
			var t = p.ctoken();
			if (t.arity != "name") {
			    t.error("Expected a property name");
			}
			t.arity = "literal";
			this.second = t;
			this.arity = "binary";
			p.advance();
			return(this);
		    },
		    gen: function (this, vmcode) {
			this.first.gen(vmcode); // object
			// this.second ALWAYS Lit!
			vmcode.emit_binop_lit(this.value, this.second.value, this);
		    },
		    gen_lhs: function (this, vmcode) {
			vmcode.emit_push(this);	// save value to store as arg
			vmcode.emit_push_lit(this.second.value, this); // member
			this.first.gen(vmcode); // object
			vmcode.emit_lhsop(this.value, this);
		    }
		}, // methods
		props: {
		    lbp: p.PDOT
		}
	    });
	    p.add_symbol_class(".", p.Dot);

	    // superclass "." operator
	    p.DotDot = Class.new({
		name: "DotDot",
		supers: [p.Dot]
	    });
	    p.add_symbol_class("..", p.DotDot);

	    // only used for ...rest (so far)
	    p.DotDotDot = Class.new({
		name: "DotDotDot",
		supers: [p.Symbol]
	    });
	    p.add_symbol_class("...", p.DotDotDot);

	    p.LBrack = Class.new({
		name: "LBrack",
		supers: [p.Infix],
		methods: {
		    led: function (this, left) {
			this.first = left;
			this.second = p.expression(0);
			this.arity = "binary";
			this.lvalue = true;
			p.advance("]");
			return(this);
		    },
		    nud: function (this) {
			var a = [];
			while (!p.check("]")) {
			    a.append(p.expression(0));
			    if (!p.check("]")) {
				p.advance(",");
			    }
			}
			p.advance("]");
			this.first = a;
			this.arity = "unary";
			return(this);
		    },
		    gen: function (this, vmcode) {
			if (this.arity == "unary") {
			    vmcode.emit_new("List", this);
			    this.first.for_each(
				function (item) {
				    item.gen(vmcode); // list item
				    vmcode.emit_append(this);
				}
			    );
			    vmcode.emit_pop_temp(this); // from emit_new
			}
			else {
			    this.gen_infix(vmcode);
			}
		    },
		    gen_lhs: function (this, vmcode) {
			vmcode.emit_push(this); // value to store
			vmcode.gen_push(this.second); // index
			this.first.gen(vmcode); // container
			vmcode.emit_lhsop(this.value, this);
		    }
		}, // methods
		props: {
		    lbp: p.PIDX
		}
	    });
	    p.add_symbol_class("[", p.LBrack);

	    p.LParen = Class.new({
		name: "LParen",
		supers: [p.Infix],
		methods: {
		    nud: function (this) {	// (expr)
			var e = p.expression(0);
			p.advance(")");
			return(e);		// this node discarded
		    },
		    led: function (this, left) { // parse function call
			var a = [];
			var spread = false;
			if (!p.check(")")) {
			  leave_while:
			    while (true) {
				if (p.check("...")) {
				    var arg = p.ctoken();
				    p.advance();
				    arg.first = p.expression(0);
				    a.append(arg);
				    spread = true; // spread arguments used
				}
				else {
				    a.append(p.expression(0));
				}
				if (!p.check(",")) {
				    leave_while();
				}
				p.advance(",");
			    }
			}
			p.advance(")");
			this.arity = "binary";
			this.first = left;
			this.second = a; // actuals
			this.third = spread; // bool: spread args present
			// removed check that function is a variable
			return(this);
		    }, // led
		    gen: function (this, vmcode) {
			if (this.third) { // ...args present
			    // generate code for actuals, placing them on stack
			    this.second.each_for(
				function (actual) {
				    if (actual.check("...")) {
					vmcode.gen_push(actual.first);
				    }
				    else {
					vmcode.gen_push(actual);
				    }
				}
			    );

			    this.first.gen(vmcode); // function expression

			    // create vm.args list bit at a time...
			    vmcode.emit_clargs(this);
			    this.second.for_each(
				function (actual) {
				    if (actual.check("...")) {
					vmcode.emit_sprarg(this);
				    }
				    else {
					vmcode.emit_poparg(this);
				    }
				}
			    );
			    vmcode.emit_call0(this);
			} // ...args present
			else {
			    // generate code for actuals, placing them on stack
			    this.second.each_for(
				function (actual) {
				    vmcode.gen_push(actual);
				}
			    );

			    this.first.gen(vmcode); // function expression
			    vmcode.emit_call(this.second.len(), this);
			} // no ...args
		    } // gen
		}, // methods
		props: {
		    lbp: p.PFUN,
		    exp_stmt: true
		}
	    }); // LParen
	    p.add_symbol_class("(", p.LParen);

	    p.add_prefix("Not", "!");
	    p.add_prefix("BNot", "~");

	    p.Function = Class.new({
		name: "Function",
		supers: [p.Prefix],
		methods: {
		    nud: function (this) {
			var a = [];
			// XXX pass true for func. scope?
			p.scope = p.Scope.new(p.scope);

			// define read-only var for continuation
			// (without "shadow" warnings)
			p._defname_internal(this.where, "return", true);
			var t = p.ctoken();
			if (t.arity == "name") { // function NAME?
			    // NOTE!! name (currently) defined only
			    // INSIDE the function's scope, to allow
			    // recursive functions declared in hashes.
			    // Would need to make "function name ..." a legal
			    //	statement expr. (setting .exp_stmt)
			    //  to allow bare "function" outside of expression.
			    //  (would be moot point in pure expression language)
			    this.name = t.value;
			    p.define(t, true); // define function name R/O
			    p.advance();
			}
			p.advance("(");
			if (!p.check(")")) {
			    var last = false;
			  leave_while:
			    while (true) {
				if (p.check("...")) {
				    p.advance("...");
				    last = true;
				}
				t = p.ctoken();
				if (t.arity != "name") {
				    t.error("Expected a parameter name");
				}
				p.define(t); // define argument in scope
				if (!last) { // not ...args
				    a.append(t.value); // save formal name
				}
				else {
				    this.third = t.value; // ...formal name
				    p.advance();
				    leave_while();
				}
				p.advance();
				if (!p.check(",")) {
				    leave_while();
				}
				p.advance(",");
			    }
			}
			this.first = a;
			p.advance(")");
			p.advance("{");
			t = p.ctoken(); // t2?
			if (t.arity == "literal") {
			    // XXX check if Str??
			    this.doc = t.value; // XXX not visible xxl__tree
			    p.advance();
			}
			else {
			    this.doc = null;
			}
			this.second = p.statements();
			p.scope = p.scope.pop();
			p.advance("}");
			this.arity = "function";
			return(this);
		    },
		    gen: function (this, vmcode) {
			// generate VM code for function:
			var fcode = VMCode.new();
			// BEFORE ANY CALL/OP!! establish scope, pick up args
			if (this.third) { // have ...rest argument?
			    fcode.emit_args2(this.first, this.third, this);
			}
			else {
			    fcode.emit_args(this.first, this);
			}
			fcode.gen_stmts(this.second);
			// create closure (code pointer and current scope)
			vmcode.emit_close(fcode.finish(this), this);
		    }
		} // methods
	    });
	    p.add_symbol_class("function", p.Function);

	    //////////////// Statements

	    // XXX reserved = true
	    p.Stmt = Class.new({
		name: "Stmt",
		supers: [p.Symbol],
		methods: {
		    std: function (this) { this.error("Not a statement"); }
		}
	    });

	    // code block AND hash constructor
	    p.LBrace = Class.new({
		name: "LBrace",
		supers: [p.Stmt],
		methods: {
		    nud: function (this) { // { key: value .... }
			var a = [];
			var what; // undecided
			var n;	// name/key
			var v;	// value
		      leave_while:
			while (!p.check("}")) {
			    n = p.ctoken();
			    if (n.arity != "name"
				&& n.arity != "literal") {
				n.error(
				    (what ? what : "Set/Dict") +
				     " key must be name or number");
			    }
			    p.advance();
			    if (!what) {
				if (p.check(",") || p.check("}")) {
				    what = "Set";
				}
				else if (p.check(":")) {
				    what = "Dict";
				}
				else {
				    p.ctoken().error("syntax error");
				}
			    }
			    if (what == "Dict") {
				p.advance(":");
				n.first = p.expression(0);
			    }
			    a.append(n);
			    if (p.check("}")) {
				leave_while();
			    }
			    p.advance(",");
			}
			p.advance("}");
			this.first = a;
			this.second = what ? what : "Dict"; // {} is Dict
			this.arity = "unary";
			return(this);
		    }, // nud
		    std: function (this) { // { block }
			p.scope = p.Scope.new(p.scope);	 // before label defined
			if (this.second) { // label?
			    p.define(this.second, true); // read-only!
			}
			p.advance("{"); // must be AFTER label defined!
			this.first = p.statements();
			p.scope = p.scope.pop();
			p.advance("}");
			this.arity = "statement";
			return(this); // no longer discards LBrace stmt node!
		    },
		    gen: function (this, vmcode) {
			if (this.arity == "statement") { // { block }
			    var bcode = VMCode.new(); // block closure code
			    bcode.emit_scope(this.second, this);
			    bcode.gen_stmts(this.first);
			    // create block closure & invoke
			    vmcode.emit_bclose_call(bcode, this);
			}
			else {	// unary { attr: value ... } or { setitem ... }
			    vmcode.emit_new(this.second, this);
			    if (this.second == "Dict") {
				// first is list of lit/name keys,
				// each with a value expression on "first"
				this.first.for_each(
				    function (item) {
					// value to store
					vmcode.gen_push(item.first);
					// key
					vmcode.emit_push_lit(item.value, this);
					// get dict back in AC
					vmcode.emit_temp(this);
					vmcode.emit_lhsop("[", this);
				    }
				); // for_each
			    } // Dict
			    else { // Set
				this.first.for_each(
				    function (item) {
					vmcode.emit_push_lit(item.value, this);
					vmcode.emit_temp(this); // get Set in AC
					vmcode.emit_binop_lit(".", "add", this);
					vmcode.emit_call(1, this);
				    }
				);
			    } // Set
			    vmcode.emit_pop_temp(this); // leave Dict/Set in AC
			} // unary
		    } // gen
		} // methods
	    }); // LBrace
	    p.add_symbol_class("{", p.LBrace);

	    p.Var = Class.new({
		name: "Var",
		supers: [p.Stmt],
		methods: {
		    std: function (this) {
			var t;
			this.arity = "statement";
			var n = p.ctoken();
			if (n.arity != "name") {
			    n.error("Expected a new variable name");
			}
			if (n.reserved) {
			    n.error(n.value.repr() + " reserved");
			}
			var read_only = this.value == "const";
			p.define(n, read_only); // define variable
			this.first = n;
			p.advance(n.value); // consume variable name

			// "const" requires value!!
			if (p.check("=") || read_only) {
			    p.advance("=");
			    this.second = p.expression(0);
			}
			p.advance(";");
			return(this);
		    },
		    gen: function (this, vmcode) {
			vmcode.emit_var(this.first.value, this);
			if (this.second) {
			    this.second.gen(vmcode); // expr
			    vmcode.emit_store(this.first.value, this); // var
			}
		    } // gen
		}
	    }); // Var
	    p.add_symbol_class("var", p.Var);
	    p.add_symbol_class("const", p.Var);

	    p.If = Class.new({
		name: "If",
		supers: [p.Stmt],
		methods: {
		    std: function (this) {	// parse
			p.advance("(");
			this.first = p.expression(0);
			p.advance(")");
			this.second = p.block();

			// This will cause REPL to block for next token. Sorry!
			// node.js seems to avoid this, only continues
			// on "} else ...."  (could have a "peek"
			// which won't look across lines?)
			if (p.check("else")) { 
			    p.reserve();
			    p.advance("else");
			    // XXX change "else if" exception to "elif"?
			    this.third = (p.check("if") ?
					  p.statement() : p.block());
			}
			else {
			    this.third = null;
			}
			this.arity = "statement";
			return(this);
		    },
		    gen: function (this, vmcode) { // gen
			this.first.gen(vmcode); // condition
			var not_true_label = vmcode.def_fwd_label();
			vmcode.emit_ifnot(not_true_label, this);
			// gen_stmt? should be LBrace??:
			this.second.gen(vmcode);
			if (this.third) { // have else?
			    var end_label = vmcode.def_fwd_label();
			    vmcode.emit_jrst(end_label, this);
			    vmcode.drop_fwd_label(not_true_label);
			    // else stmt(s) [vmcode.gen_stmt?]:
			    this.third.gen(vmcode);
			    vmcode.drop_fwd_label(end_label);
			}
			else {
			    vmcode.drop_fwd_label(not_true_label);
			}
		    } // if.gen
		}
	    }); // If
	    p.add_symbol_class("if", p.If);

	    // parsed via peek-ahead in this.statement()
	    p.Label = Class.new({
		name: "Label",
		supers: [p.Stmt],
		methods: {
		    std: function (this) {	// parse
			var n = p.ctoken();
			if (n.arity != "name") {
			    n.error("Expected a label name");
			}
			if (n.reserved) {
			    n.error(n.value.repr() + " reserved.");
			}
			p.scope = p.Scope.new(p.scope);
			p.define(n, true); // define variable for label as R/O
			this.arity = "statement";
			this.first = n;
			p.advance();
			p.advance(":");
			this.second = p.statement(true); // recurse!
			p.scope = p.scope.pop();
			return(this);
		    },
		    gen: function (this, vmcode) { // gen
			// wrap entire statement in a closure w/ leave label
			var lcode = VMCode.new();
			lcode.emit_scope(this.first, this);
			this.second.gen(lcode); // vmcode.gen_stmt?
			// create block closure and invoke
			vmcode.emit_bclose_call(lcode, this);
		    } // label.gen
		}
	    }); // Label
	    // NOTE! not a keyword!

	    p.While = Class.new({
		name: "While",
		supers: [p.Stmt],
		methods: {
		    std: function (this) {	// parse
			p.advance("(");
			this.first = p.expression(0);
			p.advance(")");
			this.second = p.block();
			this.arity = "statement";
			return(this);
		    },
		    gen: function (this, vmcode) { // gen
			// generate closure for body, w/ leave label, if any
			var leave_sym = this.second.second;
			var wcode = VMCode.new(); // code for block closure
			wcode.emit_scope(leave_sym, this);
			var top_branch_label = wcode.get_off();
			this.first.gen(wcode); // condition
			var done_branch_label = wcode.def_fwd_label();
			wcode.emit_ifnot(done_branch_label, this);
			this.second.gen(wcode);
			wcode.emit_jrst(top_branch_label, this);
			wcode.drop_fwd_label(done_branch_label);

			// create closure around entire while stmt and invoke
			vmcode.emit_bclose_call(wcode, this);
		    }
		}
	    }); // p.while
	    p.add_symbol_class("while", p.While);
	}, // Parser.init()

	// XXX move to PrattParser?
	add_terminal: function (this_parser, name, id, super) {
	    var C = Class.new({
		name: name,
		supers: [super || this_parser.Symbol]
	    });
	    this_parser.add_symbol_class(id, C);
	    return(C);
	}, // add_terminal

	// XXX move to PrattParser?
	add_infix: function(this_parser, name, id, right, lbp) {
	    // helper to generate simple infix Symbol classes
	    var C = Class.new({
		name: name,
		supers: [right ? this_parser.InfixR : this_parser.Infix],
		props: { lbp: lbp }
	    });
	    this_parser.add_symbol_class(id, C);
	},

	// XXX move to PrattParser?
	add_prefix: function (this_parser, name, id) {
	    // helper to generate simple prefix Symbol classes
	    var C = Class.new({
		name: name,
		supers: [this_parser.Prefix]
	    });
	    this_parser.add_symbol_class(id, C);
	},

	statements: function (this) {
	    """
	    Parse a series of statements, returning List.
	    Called for function body, block, whole file compile.
	    """
	    var a = [];
	    while (!this.check_end_block()) {
		a.append(this.statement());
	    }
	    return(a);
	}, // statements

	block: function (this) { // [LABEL ":"] "{" STATEMENTS "}"
	    var label;
	    var t = this.ctoken();
	    if (t.arity == "name") { // label name?
		label = t;	     // save it
		this.advance();
		this.advance(":");
		t = this.ctoken();
	    }

	    // was advance, but reads first token in block,
	    // (and if it was a reference to the label on the block,
	    // it would come up undefined), so advance moved to LBrace.std
	    this.check("{");
	    t.second = label;	// attach label (if any) to LBrace
	    return(t.std());
	},
	start_parse: function (this, fname) { // get ready to parse
	    // parens, brackets and braces are non-combining.
	    // tempting to allow braces, but would require '{ }' for empty Dict!
	    // (unless they only combined with their own kind '{{' and '}}')
	    var oprs = '!@#$%^&*-=+<>\|:,./?~';
	    // was: '=<>!+-*&|/%^.', '=<>&|.'
	    this..start_parse(fname, oprs, oprs);

	    // set in root_scope by classes.py classes_init()
	    this.predef("Class");
	    this.predef("__xxl");
	    this.predef("null", true);	// read-only
	    this.predef("true", true);	// read-only
	    this.predef("false", true); // read-only
	    this.predef("undefined", true); // read-only

	    // set by new_module in classes.py
	    this.predef("__modinfo");
	},

	parse: function (this, fname) {	// parse whole file
	    this.start_parse(fname);
	    // parse & execute statements one at a time (for extensions)
	    // save as a series of calls to closures???
	    var s = this.statements();
	    this.advance(this.END);
	    this.scope = this.scope.pop();
	    return(s);		// return list of statement ASTs
	},

	reset: function (this) {
	    """
	    here when interactive parse failed
	    """
	    this.reset_prompt();
	    this.reset_tokenizer();
	    this._token = this._next_token = null;
	    this.need_advance = true;
	}
    } // Parser methods
});

////////////////
// move to compile.xxl?
//	(regression test will need to do "-P x.vmx")
//
// main program to compile an XXL file, return VMX (VM metadata and code) JSON
// for regression testing, creating .vmx files (parser.vmx, bootstrap.vmx)

// NOTE!
//	compiling test programs to a .vmx file w/
//	"./xxl.py parser.xxl foo.xxl > foo.vmx"
//	and running it w/ "xxl.py -t -x foo.vmx args ...."
//	traces JUST the execution of your program,
//	since the parser (parse_and_execute) is not run.
//
//	And makes it easier to set breakpoints in the VM
//	(again, since the compiler isn't being invoked)
//	although you can always call __xxl.break in your program.

var gen = function (stmts) {	// tree is list of top level stmts/exprs
    var vmcode = VMCode.new();
    vmcode.gen_stmts(stmts);
    return(vmcode.finish(null)); // emit final return
}; // gen()

var dump_parser = function (p) {
    p.symbol_classes.items().for_each(
	function (pair) {
	    var c = pair[1];
	    var i = c.new("foo", "bar", "baz");
	    __xxl.print(pair[0], // dict key
			 c.name,  // Symbol class name
			 i.lbp,
			 // won't see inherited methods;
			 // looking at Instance sees Symbol.nud
			 (c.__methods['nud'] && "value") || "-",
			 (i.std && "stmt") || "-"
			);
	}
    );
    __xxl.exit(1);
};

var compile = function (fname, output) {
    """
    Compile code in file `fname`.
    Returns List of Str.
    Optional `output` determines format:
	'ast': string with JSON string for AST
	default: list[0]: JSON metadata
		 list[0]: JSON code
    """
    var p = Parser.new();

    // get list of abstract syntax trees (of Symbols)
    // (one per statement)
    var asts = p.parse(fname);

    if (output == "ast") {
	var j = __xxl._tree(asts); // returns big JSON string
	return([j]);
    }

    // generate VM code (as List of instruction Lists)
    var code = gen(asts);

    // create metadata line:
    var py_os = __xxl.pyimport("os");
    var py_json = __xxl.pyimport("json");
    var stat = py_os.stat(fname);
    // wanted "at" & compilation time, but breaks regression test!
    //	XXX maybe they should ignore first line?
    //		depends on Python 3.6 dict ordering!!!! hand format?!
    var d = {v: 1.0,
	     fn: fname,
	     mt: stat.st_mtime,
	     sz: stat.st_size};
    var meta_json = py_json.dumps(d);

    // get code as JSON string
    // XXX maybe option to serialize in a format
    //	that loads faster than JSON????
    var code_json = __xxl._vtree(code, fname);
    return([meta_json, code_json]);
}; // compile

if (__modinfo.main) {
    // here when run as: ./xxl.py parser.xxl sourcefile
    // OR: ./xxl.py parser.vmx sourcefile
    var output = "vmx";
    var i = 0;
    var usage = function () {
	__xxl.error("Usage: parser [--ast] SOURCEFILE");
	__xxl.exit(1);
    };

    var argc = __xxl.argv.len();
    while (i < argc && __xxl.argv[i].starts_with('-')) {
	var option = __xxl.argv[i];
	if (option == "--ast") {
	    output = "ast";
	}
	else if (option == "--dump") {
	    var p = Parser.new();
	    dump_parser(p);
	    __xxl.exit(0);
	}
	else {
	    usage();
	}
	i += 1;
    }
    if (i == argc) {
	usage();
    }
    var ret = compile(__xxl.argv[i], output);
    ret.for_each(__xxl.print);
    // no __xxl.exit, so stats visible w/o catching SystemExit Exception
} // main
