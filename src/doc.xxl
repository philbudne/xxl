// -*-js-*-

var classes = System.import("classes");

var collect_class_ops = function (class, prop) {
    """
    traverse Class hierarchy for `class`
    collecting all methods/operators from property `prop`
	(one of '_methods', '__unops', '__binops', '__lhsops')
	returns Dict of Callables
    """
    var funcs = {};
    var q = [class];
    var visited = {};
    var visit = function (c) {
	// XXX guard against revisit!!
	if (c !== classes.Object) { // XXX UGH! Stop The Looping!!!
	    q.extend(c.__supers || []);
	}
	c.getprop(prop).items().for_each(
	    function (item) {	// item is [key, value]
		var name = item[0];
		var func = item[1];
		if (!name.starts_with("_")     // ignore private methods
		    && func && !funcs[name]) { // don't overwrite!
		    funcs[name] = func;
		}
	    }
	);
    };
    while (q.len() > 0) {
	visit(q.pop(0));
    }
    return(funcs);
};

// XXX start move to markup.xxl???
var MarkUp = Class.new({
    name: "MarkUp",
    doc: "base class for marking up text",
    methods: {
	init: function (this) { this._value = []; },
	render: function (this) {
	    """
	    return final result Str
	    """
	    return("".join(this._value));
	},
	joinw: function(this, list) {
	    """
	    join words and return Str
	    """
	    return(" ".join(list));
	},
	append: function (this, ...words) {
	    """
	    append words (w/o any newlines)
	    """
	    var s = this.joinw(words);
	    if (s.len() > 0) {
		this._value.append(s);
	    }
	},
	nappend: function (this, ...words) {
	    """
	    start new line, then append words (w/ spaces)
	    """
	    if (this._value.len() > 0 && this._value[-1][-1] != "\n") {
		this._value.append("\n"); // start new line
	    }
	    if (words.len()) {
		this._value.append(this.joinw(words));
	    }
	},
	lwrap: function (this, prefix, list, suffix) {
	    """
	    wrap `list` of items between `prefix` and `suffix`
	    AND RETURN String
	    """
	    suffix = suffix || ""; // want "||=" or "??=" ??
	    var l = this.joinw(list);
	    return("".join([prefix, l, suffix]));
	},
	wrapnap: function (this, prefix, words, suffix) {
	    """
	    concatenate List of Str `words`
	    wrap in prefix/suffix
	    start new line and append
	    """
	    this.nappend(this.lwrap(prefix, words, suffix));
	}
    } // methods
});

var MarkDown = Class.new({
    name: "MarkDown",
    doc: "MarkUp class for MarkDown (.md) format!",
    supers: [MarkUp],
    methods: {
	// the following take multiple args, will space separate and APPEND.
	h1: function (this, ...args) { this.wrapnap("# ", args, "\n"); },
	h2: function (this, ...args) { this.wrapnap("## ", args, "\n"); },
	h3: function (this, ...args) { this.wrapnap("### ", args, "\n"); },
	h4: function (this, ...args) { this.wrapnap("#### ", args, "\n"); },
	h5: function (this, ...args) { this.wrapnap("##### ", args, "\n"); },
	hn: function (this, n, ...args) {
	    this.wrapnap("##########".slice(0,n) + " ", args, "\n");
	},

	hr: function (this, ...args) { this.nappend("---\n"); },
	p: function (this, ...args) { this.nappend("\n"); }, // paragraph

	// code_block?
	// (un)ordered_list (take list)??

	// NOTE!! the following RETURN strings:
	bold: function (this, ...words) { // cannot be combined w/ i??
	    return(this.lwrap("**", words, "**"));
	},
	i: function (this, ...words) { // cannot be combined w/ bold?!
	    return(this.lwrap("*", words, "*"));
	},
	code: function (this, ...words) {
	    return(this.lwrap("`", words, "`"));
	}
    }
});
// XXX end move to markup.xxl???

var mufunc = function (mu, level, name, func) {
    var args = func.__args() || "";
    mu.hn(level, mu.code(name, args));
    var defn = func.__defn();
    if (defn) {
	// no blank line?
	mu.nappend(mu.i(func.getclass().name, "defined at", defn));
    }
    var doc = func.__doc;
    if (doc) {
	mu.p();
	mu.append(doc);
	mu.nappend();
    }
};

var muclass = function (mu, class) {
    """
    `mu` is a MarkUp instance
    `class` is a Class (metaclass) to document
    """

    if (class.__doc) {
	mu.append(class.__doc);
	mu.p();
    }

    [
     ['__methods', 'Methods'],
     ['__unops', 'Unary operators'],
     ['__binops', 'Binary operators'],
     ['__lhsops', 'LHS Binary operators']
    ].for_each(			// for_each property
	 function (pitem) {	// pitem => ["property", "english"]
	     mu.h3(pitem[1]);	// english name
	     mu.p();
	     var d = collect_class_ops(class, pitem[0]); // returns Dict
	     d.items().sorted().for_each(
		 function (ditem) { // ditem => [method/op_name, function]
		     var name = ditem[0]; // method name or operator string
		     var func = ditem[1]; // Callable
		     mufunc(mu, 4, name, func);
		 }
	     );
	 } // function (pitem)
    ); // for_each property
};

var describe_module = function (mu, module_name) {
    mu.h1(mu.code(module_name), "Module");
    mu.p();

    // iterate over sorted names in Module
    var mod = System.import(module_name);
    var vars = [];
    mod..props().sorted().for_each(
	function (name) {
	    if (name.starts_with("_")) {
		return();
	    }
	    var x = mod.getprop(name);
	    if (x.instance_of(classes.Class)) {
		mu.h2("Class", mu.code(name));
		mu.p();
		muclass(mu, x);
	    }
	    else {
		vars.append(name);
	    }
	}
    );
    mu.h2("Variables");
    mu.p();
    vars.for_each(
	function (name) {
	    var x = mod.getprop(name);
	    if (x.instance_of(classes.Callable)) {
		mu.h3(mu.code(name, x.__args()));
		mu.nappend(x.__doc);
	    }
	    else {
		mu.h3(mu.code(name));
		mu.p();
		mu.nappend("Value:", mu.code(x.to_str()));
	    }
	    mu.p();
	}
    );
};

if (__modinfo.main) {
    var module_name = System.argv.len() > 0 ? System.argv[0] : "classes";

    var markup_class = MarkDown;	// XXX take option for format!!
    var mu = markup_class.new();

    describe_module(mu, module_name);

    mu.hr();
    var time = System.pyimport("time");
    mu.nappend("formatted by doc.xxl on",
	       time.strftime("%Y-%m-%d")); // XXX want UTC

    // The very very very end.
    System.print(mu.render());	// output results
}
