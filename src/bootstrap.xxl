// -*-js-*-

// The pre-compiled version of this file (bootstrap.vmx) is loaded
// into every new module namespace.

// Parses and executes source file (if any) one line at a time so that
// parser extensions are available as soon as they are added!!

if (__modinfo.booting) {
    System.uerror("bootstrap: already running!");
}
__modinfo.booting = true;

System.import = function (name) {
    """
    import a source file, VM instruction (.vmx) file, or internal module.
    returns Module.
    """
    var rets = System._import(name);
    var mod  = rets[0];	// Module
    var boot = rets[1];	// Closure for bootstrap.vmx (first time only)

    if (boot) {
	boot();
    }

    // check for parser extensions at "well known" name:
    var xp = mod.__extend_parser;
    if (xp) {			// XXX ignore if asked?
	xp(__modinfo.parser);
    }
    return(mod);
};

if (__modinfo.main) {		// once only
    ////////////////////////////////////////////////////////////////
    // native code methods for built-in Classes

    var classes = System.import("classes");

    ////////////////
    // Object

    // default this.to_str() to this.repr():
    classes.Object.__methods['to_str'] = function (this) {
	"""
	default to_str method: calls this.repr
	"""
	return(this.repr());
    };

    ////////////////
    // Class

    // default 'new' method!!
    classes.Class.__methods['new'] = function (this_class, ...args) {
	"""
	default metaclass (Class) new method
	manually invoked as SomeClass.new
	calls this_class.create to create obj
	and then calls obj.init()
	"""
	var obj = this_class.create();
	obj.init(...args);
	return(obj);
    };

    ////////////////
    // Iterable (subclasses w/ .iter() and .reversed() methods)

    var Iterable = classes.Iterable;

    Iterable.__methods['for_each'] = function (this, func) {
	"""
	call `func` argument with each iterator item
	"""
	var iter = this.iter();
	while (true) {
	    func(iter.next(return));
	}
    };

    Iterable.__methods['each_for'] = function (this, func) {
	"""
	call `func` argument with each reverse iterator item
	"""
	var iter = this.reversed();
	while (true) {
	    func(iter.next(return));
	}
    };

    Iterable.__methods['map'] = function (this, func) {
	"""
	return List of results of `func` passed each iterator item
	"""
	var iter = this.iter();
	var ret = [];
      break_while:
	while (true) {
	    ret.append(func(iter.next(break_while)));
	}
	return(ret);
    };

    // ignore entries where func returns `ignore` value
    Iterable.__methods['map2'] = function (this, func, ignore) {
	"""
	return List of results of `func` passed each iterator item,
	ignore any returns with value `ignore` (defaults to `null`)
	"""
	var iter = this.iter();
	var ret = [];
      break_while:
	while (true) {
	    var x = func(iter.next(break_while));
	    if (x != ignore) {
		ret.append(x);
	    }
	}
	return(ret);
    };

    ////////////////
    // Dict

    classes.Dict.__methods['init'] = function (this, arg) {
	"""
	init method for Dict: takes Iterable returning two-item lists,
	OR an Iterable returning keys, and implementing '['
	"""
	this.__init0();
	if (!arg.instance_of(classes.Iterable)) {
	    System.uerror(this.name + ".init needs iterable");
	}
	var iter = arg.iter();
	while (true) {
	    var item = iter.next(return);
	    // if first item, set sentinal
	    // make sure all following items of same size/shape
	    if (item.instance_of(classes.List)) {
		if (item.len() != 2) {
		    System.uerror(this.name + ".init got List w/ len != 2");
		}
		this[item[0]] = item[1];
	    }
	    else {
		this[item] = arg[item];
	    }
	}
    };

    classes.Dict.__methods['repr'] = function (this) {
	"""
	return representation of Dict
	"""
	var items = [];
	this.for_each(
	    function (key) {
		items.append(key.repr() + ": " + this[key].repr());
	    }
	);
	return("{" + ", ".join(items) + "}");
    };

    ////////////////
    // List

    classes.List.__methods['init'] = function (this, arg) {
	"""
	init method for List: takes Iterable
	"""
	this.__init0();
	if (!arg.instance_of(classes.Iterable) && !arg.iter) {
	    System.uerror(this.name + ".init needs Iterable");
	}
	this.extend(arg);
    };

    var repr = function (x) { return(x.repr()); };
    classes.List.__methods['repr'] = function (this) {
	"""
	return represtation of List
	"""
	return("[" + ", ".join(this.map(repr)) + "]");
    };

    classes.List.__methods['extend'] = function (this, iterable) {
	var iter = iterable.iter();
	while (true) {
	    this.append(iter.next(return));
	}
	// NOTE: modifies List: not chainable in Python
    };

    ////////////////
    // Number

    classes.Number.new = function (x) {
	"""
	Return a `Number` object with value `x`
	NOTE!! A static method, not a (Meta)class method!!!
	"""
	return(x.to_number());
    };

    ////////////////
    // Str

    classes.Str.__methods['join'] = function (this, iterable) {
	if (iterable.instance_of(classes.List)) {
	    return(this.__join(iterable));
	}
	else if (iterable.instance_of(classes.Iterable)) {
	    var list = classes.List.new(iterable);
	    return(this.__join(list));
	}
	else {
	    System.uerror(this.name + ".join needs Iterable");
	}
    };

} // main / once only

if (true) {			// all modules-- hide temp variables
    ////////////////
    // print
    var py_sys = System.pyimport("sys");

    var str = function (x) {
	return(x.to_str());
    };

    var __print = function (file, l) {
	file.write(" ".join(l.map(str)) + "\n");
    };

    var pr = function (...args) {
	"""
	print args (as strings) to stdout
	"""
	__print(py_sys.stdout, args);
    };
    System.print = pr;

    var er = function (...args) {
	"""
	print args (as strings) to stderr
	"""
	__print(py_sys.stderr, args);
	py_sys.stderr.flush();
    };
    System.error = er;
}

if (__modinfo.debug_bootstrap) { // from environment XXL_DEBUG_BOOTSTRAP
    System.error("bootstrap __modinfo.module", __modinfo.module);
    System.error("bootstrap __modinfo.main", __modinfo.main);
    System.error("bootstrap __modinfo.file", __modinfo.file);
}

if (__modinfo.file) {
    var file = __modinfo.file;
    if (file.ends_with(".vmx")) {
	__modinfo.load_vmx(file)(); // load vmx as Closure and invoke
	if (__modinfo.debug_bootstrap) {
	    System.error("bootstrap vmxfile", file, "finished");
	}
    } // .vmx
    else {
	var parser_vmx = __modinfo.parser_vmx; // for import
	if (__modinfo.debug_bootstrap) {
	    System.error("bootstrap parser_vmx", parser_vmx);
	}
	var pm = System.import(parser_vmx); // parser module
	var p = pm.Parser.new();	// Parser instance
	__modinfo.parser = p;	// make visible to parser extensions

	p.start_parse(file);
	while (!p.end()) {
	    // parse one statement into abstact syntax tree of Symbols
	    var ast = p.statement();

	    // generate VM code
	    var vmcode = pm.VMCode.new();
	    ast.gen(vmcode);
	    var insts = vmcode.finish(ast); // List of instruction Lists

	    // generate Closure in module initial scope and invoke
	    __modinfo.assemble(insts, file)();
	}
    } // not .vmx
} // if (__modinfo.file)
else {
    System.uerror("bootstrap: no file to load");
}
__modinfo.booting = false;
