## VM

The original interpreter for what became "XXL"
(then called ASAP for "As Simple As Possible")
evaluated the abstract syntax tree (AST)
from the parser recursively.

In order to implement continuations, the parser
was modified to generate code for a virtual machine,
which may retain the ASAP moniker.

There is not (yet) a bytecode representation for VM code.
The normal representation for VM Code is a List of Lists.

A .vmx file contains JSON:

The first line is an Object (dictionary) the following
keys for metadata:

* "v" -- version as a floating point number. Incompatible changes should
	increment the whole number part, and reset the fraction to zero.
* "fn" -- the name of the source file (used in error messages)
* "mt" -- modification time of the source file as a real number
	of seconds since 1970-01-01 UTC.
* "sz" -- size of the source file, in bytes.

The rest of the file is a list of instructions (lists).

The `__modinfo.assemble` method takes a List of Lists, and
the source filename and creates a Closure (using the base scope of the module),
The source filename is saved in each Instruction instance created.

Each instruction is a list `["LINE:CHARPOS", "OPCODE", args... ]`
Instructions that generate a code block or a function closure
take a list of instructions as an argument.

Each instruction is generated by an `emit_NAME` method of the
VMCode class in parser.xxl.

Each instruction is defined by a subclass (decorated by "@reginstr")
of VMInstr<N>, where <N> is the number of arguments to the instruction.

Each instruction class must have a "name" property, so reginstr knows
the name of the instruction to register for conversion to internal form.

The virtual machine is stack based has the following registers:

* `AC` -- Accumulator of the (primary/left) operand.
* `SP` -- Stack Pointer to a "parent pointer" (saguro/cactus) stack.
	Each stack entry is a Python tuple of (value, next).
* `CB` -- Code Base.  Points to a Python list of VMInstrX instances.
* `PC` -- Program Counter.  Offset into current code base.
* `IR` -- Instruction Register. Contains the current instruction
	(saved in call frame for errors messages and/or debug).
* `SCOPE` -- pointer to a cactus stack of Scope objects holding variable values.
* `ARGS` -- a Python list of arguments for the next "call" instruction.
* `FP` -- Frame Pointer.  Pointer to a cactus stack of tuples with the
	return stack.  Each frame includes the current `CB, PC, SCOPE, FP,
	FILENAME, "LINE:POS"` and a Bool indicating whether the frame
	should be visible in an backtrace.
* `TEMP` -- Holds pointer to a List, Dict, or Set object being built by
	[] or {} syntax sugar.

Instruction execution is as follows:
* `IR` is loaded from `CB[PC]`
* `PC` is incremented
* `IR.step(vm)` is called

A call to a Closure pushes an entry on the `FP` (cactus) stack:
`FP ← (CB, PC, SCOPE, FP, IR.filename, IR.line_pos, visible)`,
where `visible` is `true` for function closures, and `false` for block closures.

The new frame (`FP` value) will contain the `PC` index for the next instruction after the call.

NOTE: A Continuation is simply an Object wrapping an `FP` value;
Calling the Continuation puts the passed argument (if any) into `AC`
and restores the VM state from the `FP` tuple ***exactly*** as the `return` instruction does!

### The following instructions take no arguments:

* `push` -- push `AC` onto the `stack SP ← (AC, SP)`
* `return` -- return, restoring `CB, PC, SCOPE and FP` from the
	tuple referenced by `FP`
	(generated only at the end of a list of instructions).
* `exit` -- exit the VM.  Only used by internal bootstrap code.
* `uscope` -- First intruction in an unlabled block closure instruction list.
	create a new scope for a unlabeled block scope: `SCOPE ← new_scope(SCOPE)`.
* `temp` -- copy `TEMP` to `AC`:  `AC ← TEMP`.
* `pop_temp` -- load `AC` from `TEMP`, restore `TEMP` from stack: `AC ← TEMP; TEMP, TEMP ← SP`.
* `append` -- append value in `AC` to the List in `TEMP`: `TEMP.append(AC)`

### Instructions with zero args for calls using "spread arguments" `...expr`

Will always appear as a sequence that starts with `clargs`, has a mix of `sprarg` (always one or more),
and `poparg` (zero or more), ending with `call0`, that is, `ARGS` never needs to be saved or restored:
it is always created ***just*** before a call.

* `clargs` -- clear the `ARGS` list; used at the start of the call: `ARGS = []`.
* `poparg` -- pop a single value from STACK and append to `ARGS`
	(used for simple argument values).
* `sprarg` -- used for `...expr`: pop a (List) value from STACK, and use to extend the `ARGS` list:
	`x, SP ← SP; ARGS.extend(x)`.
* `call0` -- call the object in `AC`, using contents of `ARGS` as the argument list.

### Instructions with one argument:

* `lit` -- loads a JSON Number or String literal. `AC ← arg`.
* `load` -- use the String argument as the name of a variable to load
	into `AC`, using the `SCOPE` chain.
* `store` -- use the String argument as the name of a variable to store
	`AC` into, using the `SCOPE` chain.
* `unop` -- argument is a String for a unary operator to apply to `AC`.
* `binop` -- argument is a String for a binary operator to apply to `AC`.
	the second (right) argument is popped from the stack.
* `lhsop` -- argument is a String for a Left Hand Side binary operator to apply to `AC`.
	the second (right) argument is popped from the stack.
* `close` -- argument is a list of instructions to combine with SCOPE
	to create a Closure object, left in `AC`.
* `call` -- argument is the number of arguments to pop from `STACK` and append to `ARGS`
	(after first clearing `ARGS`).  `AC` points to an Object to call.
* `var` -- argument is the name of a variable to create (with value undefined)
	in the current SCOPE.
* `args` -- first instruction in a function/method Closure.
	argument is a list of strings for formal parameters.
	A new entry is pushed onto the `SCOPE` (cactus) stack:
	A new scope is created, with a parent pointer from `SCOPE`.
	`SCOPE` then is pointed to the new scope.
	The new scope is given a `return` entry with a Continuation using the value of `FP`.
	A variable is created in the new `SCOPE` for each name using the corresponding positional value
	from `ARGS`.  If/when `ARGS` is empty, the remaining formal values will be `undefined`.
	More entries in `ARGS` than in the formal parameter list is a fatal error.
* `bccall` -- argument is a list of instructions to create a block Closure which is immediately called.
	The new frame will not be visible in backtraces (`show` will be `false`).
* `lscope` -- First instruction in an instruction list for a block closure with a leave label.
	A new scope is created (see `args`).
	The argument is the name of a variable to create and load with a Continuation
	created from the current `FP`.
* `jrst` -- unconditional jump: argument is an integer code base offset value:
	`PC ← arg`
	*(Jump and ReSTore flags is the fastest unconditional jump instruction
	  on the PDP-10)*

* `jumpe` -- if `AC` contains a "falsey" value (null, undefined, false or zero),
	load `PC` from argument.
	*(`JUMPE AC,DEST` is the PDP-10 instruction for compare AC to zero
	  and jump if equal)*
* `jumpn` -- if `AC` is not "falsey", load PC from argument.
	*(`JUMPN AC,DEST` is the PDP-10 instruction for compare AC to zero
	  and jump if not equal)*
* `push_lit` -- pushes a JSON Number or String literal onto stack:
	`SP ← (value, SP)`
* `new` -- `TEMP` is pushed on stack. argument is string "List",
	"Dict" or "Set" for a new Object to create,
	and leave in `TEMP`: `SP ← (TEMP, SP); TEMP ← new_object`

### Instructions with two arguments:

* `args2` -- Like "args", for `functions` with a `...rest` argument.
	first argument is list of regular formals,
	second argument is the name of the "rest" argument
	which receives a (possibly empty) List with any remaining contents of `ARGS`.

* `binop_lit` -- First argument is a String for a binary operator,
	second argument is a literal Number or String for the second (right) argument.
