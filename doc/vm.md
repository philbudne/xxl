## VM

The original interpreter for what became "XXL"
(then called ASAP for "As Simple As Possible")
evaluated the abstract syntax tree (AST)
from the parser recursively.

In order to implement continuations, the parser
was modified to generate code for a virtual machine,
which may retain the ASAP moniker.

There is not (yet) a bytecode representation for VM code.
The normal representation for VM Code is a List of Lists.

A .vmx file contains JSON:

The first line is an Object (dictionary) the following
keys for metadata:

* "v" -- version as a floating point number. Incompatible changes should
	increment the whole number part, and reset the fraction to zero.
* "fn" -- the name of the source file (used in error messages)
* "mt" -- modification time of the source file as a real number
	of seconds since 1970-01-01 UTC.
* "sz" -- size of the source file, in bytes.

The rest of the file is an Array of instructions (Arrays).

The `__modinfo.assemble` method takes a List of Lists, and the source
file name and creates a Closure (using the base scope of the module),
The source filename is saved in each Instruction instance created.

Each instruction is a list `["LINE:CHARPOS", "OPCODE", args... ]`
Instructions that generate a code block or a function closure
take a list of instructions as an argument.

In parser.xxl, each instruction is generated by an `emit_NAME` method
of the VMCode class.

In the VM (vmx.py) each instruction is defined by a class (decorated
by "@reginstr" to register it) subclassing VMInstr<N>, where <N> is
the number of arguments to the instruction.

Each instruction class must have a "name" property, so `reginstr` knows
the name of the instruction to register for conversion to internal form.

Because continuations allow the repeated restoration of program flow/state
to an arbitrary point saved in a call frame, all VM stacks (`SP`, `FP`,
and `SCOPE`) cannot be represented as arrays (or Python lists) of
values.  Instead each new item pushed onto a stack contains a parent
pointer, which must never be changed (`SP` and `FP` point to Python
tuples, so that the entire stack entry is inviolate).  This constructs
a parent pointer tree, also called a "saguro" or "cactus" stack.  The
term "spaghetti stack" has also been used, but is not topologically
accurate.

The virtual machine is stack based, and developed from ideas in
Kent Dybvig's dissertation
["Three Implementation Models for Scheme" (pdf)](https://legacy.cs.indiana.edu/~dyb/papers/3imp.pdf),
and has the following registers:

* `AC` -- Accumulator.
* `SP` -- Stack Pointer to a "parent pointer" (saguro/cactus) stack.
	Each stack entry is a Python tuple of (value, next).  The
	stack is MOSTLY used to accumulate operator and function
	arguments, which are then transferred to `ARGS` (usually by
	the `call` instruction).  Also used to save `TEMP` before
	constructing List, Dict and Set literals, There is not
	(currently) a generic `pop` instruction for general purpose
	use of the stack!!
* `CB` -- Code Base.  Points to a Python list of VMInstrX instances.
* `PC` -- Program Counter.  Offset (int) into current code base.
* `IR` -- Instruction Register. Contains the current VMInstrX
	(for backtraces, error messages and/or debug).
* `SCOPE` -- pointer to a cactus stack of Scope objects holding variable values.
	The `SCOPE` stack represents the nested "static" or "lexical"
	function/block scopes in the source file.  Invocation of a Closure
	sets `SCOPE` to the value in effect when/where the function was defined.
* `FP` -- Frame Pointer.  Pointer to a cactus stack of NamedTuple
	Frame objects with the return stack.  Each frame includes the
	current `CB, PC, SCOPE, FP, FILENAME, "LINE:POS"` and a Bool
	indicating whether the frame should be visible in an backtrace
	(block closures are not visible).
* `ARGS` -- a Python list of arguments for the next "call" instruction (*).
* `TEMP` -- Holds pointer to a List, Dict, or Set object being built by
	[] or {} syntax sugar (*).

(*) `ARGS` and `TEMP` are not saved in call frames.  `ARGS` is only
valid between `call` and `args` instructions (or `clargs` and `args`
instructions) for Closures.  The `TEMP` register is a "caller saves"
register, with values saved on `SP` by `new` and restored by
`pop_temp`.  The `IR` register is not saved in its entirety (only the
filename and position information is saved, and those values are
discarded when a frame is restored).

Instruction execution is as follows:
* `IR` is loaded from `CB[PC]`
* `PC` is incremented
* `IR.step(vm)` is called

A call to a Closure pushes an tuple on the `FP` (cactus) stack:
`FP ← Frame(CB, PC, SCOPE, FP, IR.filename, IR.line_pos, visible)`,
where:
* `visible` is `True` for function closures, and `False` for block closures.
* the `PC` index is for the instruction after the call.

Since the "normal" representation of opcodes is JSON, JavaScript type
names (String, Number) are used to describe the argument types.

### The following instructions take no arguments:

* `push` -- push `AC` onto the `stack SP ← (AC, SP)`
* `return` -- return, restoring `CB, PC, SCOPE and FP` from the
	tuple referenced by `FP`
	(generated only at the end of a list of instructions).
* `exit` -- exit the VM.  Only used by internal bootstrap code.
* `uscope` -- First intruction in an unlabled block closure instruction list.
	create a new scope for a unlabeled block scope: `SCOPE ← new_scope(SCOPE)`.

### Instructions with no arguments used for List, Dict and Set literal creation:

* `temp` -- copy `TEMP` to `AC`:  `AC ← TEMP`.
* `pop_temp` -- load `AC` from `TEMP`, restore `TEMP` from stack: `AC ← TEMP; TEMP, TEMP ← SP`.
* `append` -- append value in `AC` to the List in `TEMP`: `TEMP.append(AC)`

### Instructions with one argument:

* `lit` -- loads a Number or String literal. `AC ← arg`.
* `load` -- use the String argument as the name of a variable to load
	into `AC`, using the `SCOPE` chain.
* `store` -- use the String argument as the name of a variable to store
	`AC` into, using the `SCOPE` chain.
* `unop` -- argument is a String for a unary operator to apply to Object in `AC`.
* `binop` -- argument is a String for a binary operator to apply to Object in `AC`.
	the second (right) argument is popped from the stack.
* `lhsop` -- argument is a String for a Left Hand Side binary operator
	to apply to Object in `AC`.  The value to store is popped from
	the stack, then the second (right) argument of the operator is
	popped from the stack.
* `close` -- argument is a list of instructions to combine with SCOPE
	to create a Closure object, which is left in `AC`.
* `call` -- argument is the number of arguments to pop from `STACK` and append to `ARGS`
	(after first clearing `ARGS`).  `AC` points to an Object to call.
* `var` -- argument is the name of a variable to create (with value undefined)
	in the current SCOPE.
* `args` -- first instruction in a normal function/method Closure.
	argument is a list of strings for formal parameters.
	A new entry is pushed onto the `SCOPE` (cactus) stack:
	1. A new scope is created, with a parent pointer from `SCOPE`.
	2. `SCOPE` then is pointed to the new scope.
	3. The new scope is given a `return` entry with a Continuation using the value of `FP`.
	4. A variable is created in the new `SCOPE` for each name using the corresponding positional value
	   from `ARGS`.  If/when `ARGS` is empty, the remaining formal values will be `undefined`.
	   More entries in `ARGS` than in the formal parameter list is a fatal error.

	A Continuation is simply a callable Object wrapping an `FP`
	value; Calling the Continuation puts the passed argument (if
	any) into `AC` and then restores the VM state from the `FP`
	tuple ***exactly*** (using the same `vm.restore_frame` method)
	as the `return` instruction does!

	See `args2` for calls which contain `...rest` formals.

* `bccall` -- argument is a list of instructions to create a Block
	Closure which is immediately called.  The new frame will not
	be visible in backtraces (`show` will be `false`).  The first
	instruction in a Block Closure will be either `uscope` or
	`lscope`, depending on whether the block has a leave label.

* `lscope` -- First instruction in an instruction list for a block
	closure with a leave label.  A new scope is created (see
	`args`).  The argument is the name of a const variable to
	create and load with a Continuation created from the current
	`FP`.

* `jrst` -- unconditional jump: argument is an integer code base offset value:
	`PC ← arg`
	*(Jump and ReSTore flags is the fastest unconditional jump instruction
	  on the PDP-10)*

* `jumpe` -- if `AC` contains a "falsey" value (null, undefined, false or zero),
	load `PC` from argument.
	*(`JUMPE AC,DEST` is the PDP-10 instruction for compare AC to zero
	  and jump if equal)*
* `jumpn` -- if `AC` is not "falsey", load PC from argument.
	*(`JUMPN AC,DEST` is the PDP-10 instruction for compare AC to zero
	  and jump if not equal)*
* `push_lit` -- pushes a JSON Number or String literal onto stack:
	`SP ← (value, SP)`
* `new` -- `TEMP` is pushed on stack. argument is string "List",
	"Dict" or "Set" for a new Object to create,
	and leave in `TEMP`: `SP ← (TEMP, SP); TEMP ← arg_class.new()`

### Instructions with two arguments:

* `args2` -- Like "args", for `functions` with a `...rest` argument.
	first argument is list of regular String formal names,
	second argument is the String name of the "rest" argument
	which receives a (possibly empty) List with any remaining contents of `ARGS`.

* `binop_lit` -- First argument is a String for a binary operator,
	second argument is a literal Number or String for the second (right) argument.

### Instructions with zero args for calls using "spread arguments" `...expr`

These will always appear as a sequence that starts with `clargs`, has
a mix of one or more `sprarg` ops, and zero or more `poparg` ops,
ending with `call0`, that is, `ARGS` never needs to be saved or
restored: it is always created ***just*** before a call, and consumed
by invoke, or the `args` (or `args2`) op at the start of a Closure.

* `clargs` -- clear the `ARGS` list; used at the start of the call: `ARGS = []`.
* `poparg` -- pop a single value from STACK and append to `ARGS`
	(used for simple argument values).
* `sprarg` -- used for `...expr`: pop a (List) value from STACK, and use it to extend the `ARGS` list:
	`x, SP ← SP; ARGS.extend(x)`.
* `call0` -- call the object in `AC`, using contents of `ARGS` as the argument list.
