## VM

The original interpreter for what became "XXL"
(then called ASAP for "As Small As Possible")
evaluated the abstract syntax tree (AST)
from the parser recursively.

In order to implement continuations, the parser
was modified to generate code for a virtual machine,
which may retain the ASAP moniker.

There is not (yet) a bytecode representation for VM code.
The normal representation for VM Code is a List of Lists.

A .vmx file contains JSON:

The first line is an Object (dictionary) the following
keys for metadata:

* "v" -- version as a floating point number. Incompatible changes should
	increment the whole number part, and reset the fraction to zero.
* "fn" -- the name of the source file (used in error messages)
* "mt" -- modification time of the source file as a real number
	of seconds since 1970-01-01 UTC.
* "sz" -- size of the source file, in bytes.

The rest of the file is a list of instructions (lists).

The __modinfo.assemble method also takes a List of Lists to use to
create a Closure (using the base scope of the module).

Each instruction is a list ["LINE:CHARPOS", "OPCODE", args... ]
Instructions that generate a code block or a function closure
take a list of instructions as an argument.

Each instruction is generated by an emit_NAME method of the
VMCode class in parser.xxl.

Each instruction is defined by a subclass (decorated by "@reginstr")
of VMInstr<N>, where <N> is the number of arguments to the instruction.

Each instruction class must have a "name" property, so reginstr knows
the name of the instruction.

The virtual machine is stack based has the following registers:

* AC -- Accumulator of the (primary/left) operand.
* SP -- Stack Pointer to a "parent pointer" (saguro/cactus) stack.
	Each stack entry is a Python tuple of (value, next).
* CB -- Code Base.  Points to a Python list of VMInstrX instances.
* PC -- Program Counter.  Offset into current code base.
* IR -- Instruction Register. Contains the current instruction
	(for errors messages and/or debug).
* SCOPE -- pointer to a cactus stack of Scope objects holding variable values.
* ARGS -- a Python list of arguments for the next "call" instruction.
* FP -- Frame Pointer.  Pointer to a cactus stack of tuples with the
	return stack.  Each frame includes the current CB, PC, SCOPE, FP,
	FILENAME, "LINE:POS" and a Bool indicating whether the frame
	should be visible in an backtrace.
* TEMP -- Holds pointer to a List or Dict object being built by 
	[] or {} syntax sugar.


### The following instructions take no arguments:

* `push` -- push AC onto the `stack SP <- (AC, SP)`
* `temp` -- copy TEMP to AC  `AC <- TEMP`
* `pop_temp` -- load AC from TEMP, restore TEMP from stack: `AC <- TEMP; TEMP, TEMP <- SP`.
* `append` -- append value in AC to the List in TEMP: `TEMP.append(AC)`
* `return` -- return, restoring CB, PC, SCOPE and FP from the contents of FP.
	(generated only at the end of a list of instructions).
* `exit` -- exit the VM.  Only used by internal bootstrap code.
* `uscope` -- First intruction in an unlabled block closure instruction list.
	create a new scope for a unlabeled block scope: `SCOPE <- new_scope(SCOPE)`.

### Instructions with zero args for calls using "spread arguments" `...expr`

* `clargs` -- clear the ARGS list; used at the start of the call: `ARGS = []`
* `poparg` -- pop a single value from STACK and append to ARGS
	(used for plain args in calls that use `...expr`)
* `sprarg` -- extend the ARGS list using the list referenced by AC: `ARGS.extend(AC)`
	(used for `...expr`)
* `call0` -- call the object in AC, using contents of ARGS as the argument list.
	Saves a new frame with the contents of the CB, PC, SCOPE and FP registers.


### Instructions with one argument:

* `lit` -- loads a JSON Number or String literal. `AC <- arg0`.
* `load` -- use the String argument as the name of a variable to load
	into AC using the SCOPE chain.
* `store` -- use the String argument as the name of a variable to store
	AC using the SCOPE chain.
* `unop` -- argument is a String for a unary operator to apply to AC.
* `binop` -- argument is a String for a binary operator to apply to AC.
	the second (right) argument is popped from the stack.
* `lhsop` -- argument is a String for a Left Hand Side binary operator to apply to AC.
	the second (right) argument is popped from the stack.
* `close` -- argument is a list of instructions to combine with SCOPE
	to create a Closure object, left in AC.
* `call` -- argument is the number of arguments to pop from stack and append to ARGS
	(after clearing ARGS first).  AC points to an Object to call.
* `var` -- argument is the name of a variable to create (with value undefined)
	in the current SCOPE.
* `args` -- argument is a list of strings for formal parameters.
	generated at the start of a Closure.  A new scope is established,
	with a parent pointer from SCOPE.  SCOPE then is pointed to the new scope.
	A variable is created in the new SCOPE for each name using the corresponding value
	from ARGS.  If/when ARGS is empty, the variable value is null.
	More entries in ARGS than in the formal parameter list is a fatal error.
* `bccall` -- argument is a list of instructions to create a block Closure which is immediately called.
* `lscope` -- First instruction in an instruction list for a block closure with a leave label.
	Argument is the name of a variable to create and load with a Continuation
	created from FP.
* `jrst` -- argument is an integer PC (code base offset) value: `PC <- arg`
* `jumpe` -- if AC contains a `falsey` value (null, undefined, false or zero),
	load PC from argument.
* `jumpn` -- if AC is not `falsey`, load PC from argument.
* `push_lit` -- pushes a JSON Number or String literal onto stack: `SP <- (value, SP)`
* `new` -- TEMP is pushed on stack. argument is string "List", "Dict" or "Set" for a new Object to create,
	and leave in TEMP: `SP <- (TEMP, SP); TEMP <- new_object`

### Instructions with two arguments:

* `args2` -- Like "args", for `functions` with a `...rest` argument.
	first argument is list of regular formals,
	second argument is the name of the "rest" argument
	which receives a (possibly empty) List with any remaining contents of ARGS.

* `binop_lit` -- First argument is a String for a binary operator,
	second argument is a literal Number or String for the second (right) argument.
